
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `MatchTeamMapStat` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model MatchTeamMapStat
 * 
 */
export type MatchTeamMapStatModel = runtime.Types.Result.DefaultSelection<Prisma.$MatchTeamMapStatPayload>

export type AggregateMatchTeamMapStat = {
  _count: MatchTeamMapStatCountAggregateOutputType | null
  _avg: MatchTeamMapStatAvgAggregateOutputType | null
  _sum: MatchTeamMapStatSumAggregateOutputType | null
  _min: MatchTeamMapStatMinAggregateOutputType | null
  _max: MatchTeamMapStatMaxAggregateOutputType | null
}

export type MatchTeamMapStatAvgAggregateOutputType = {
  score: number | null
}

export type MatchTeamMapStatSumAggregateOutputType = {
  score: number | null
}

export type MatchTeamMapStatMinAggregateOutputType = {
  score: number | null
  isWinner: boolean | null
  initialSide: string | null
  matchMapId: string | null
  matchTeamId: string | null
}

export type MatchTeamMapStatMaxAggregateOutputType = {
  score: number | null
  isWinner: boolean | null
  initialSide: string | null
  matchMapId: string | null
  matchTeamId: string | null
}

export type MatchTeamMapStatCountAggregateOutputType = {
  score: number
  isWinner: number
  initialSide: number
  matchMapId: number
  matchTeamId: number
  _all: number
}


export type MatchTeamMapStatAvgAggregateInputType = {
  score?: true
}

export type MatchTeamMapStatSumAggregateInputType = {
  score?: true
}

export type MatchTeamMapStatMinAggregateInputType = {
  score?: true
  isWinner?: true
  initialSide?: true
  matchMapId?: true
  matchTeamId?: true
}

export type MatchTeamMapStatMaxAggregateInputType = {
  score?: true
  isWinner?: true
  initialSide?: true
  matchMapId?: true
  matchTeamId?: true
}

export type MatchTeamMapStatCountAggregateInputType = {
  score?: true
  isWinner?: true
  initialSide?: true
  matchMapId?: true
  matchTeamId?: true
  _all?: true
}

export type MatchTeamMapStatAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which MatchTeamMapStat to aggregate.
   */
  where?: Prisma.MatchTeamMapStatWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MatchTeamMapStats to fetch.
   */
  orderBy?: Prisma.MatchTeamMapStatOrderByWithRelationInput | Prisma.MatchTeamMapStatOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.MatchTeamMapStatWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` MatchTeamMapStats from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MatchTeamMapStats.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned MatchTeamMapStats
  **/
  _count?: true | MatchTeamMapStatCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: MatchTeamMapStatAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: MatchTeamMapStatSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: MatchTeamMapStatMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: MatchTeamMapStatMaxAggregateInputType
}

export type GetMatchTeamMapStatAggregateType<T extends MatchTeamMapStatAggregateArgs> = {
      [P in keyof T & keyof AggregateMatchTeamMapStat]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateMatchTeamMapStat[P]>
    : Prisma.GetScalarType<T[P], AggregateMatchTeamMapStat[P]>
}




export type MatchTeamMapStatGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.MatchTeamMapStatWhereInput
  orderBy?: Prisma.MatchTeamMapStatOrderByWithAggregationInput | Prisma.MatchTeamMapStatOrderByWithAggregationInput[]
  by: Prisma.MatchTeamMapStatScalarFieldEnum[] | Prisma.MatchTeamMapStatScalarFieldEnum
  having?: Prisma.MatchTeamMapStatScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: MatchTeamMapStatCountAggregateInputType | true
  _avg?: MatchTeamMapStatAvgAggregateInputType
  _sum?: MatchTeamMapStatSumAggregateInputType
  _min?: MatchTeamMapStatMinAggregateInputType
  _max?: MatchTeamMapStatMaxAggregateInputType
}

export type MatchTeamMapStatGroupByOutputType = {
  score: number
  isWinner: boolean
  initialSide: string
  matchMapId: string
  matchTeamId: string
  _count: MatchTeamMapStatCountAggregateOutputType | null
  _avg: MatchTeamMapStatAvgAggregateOutputType | null
  _sum: MatchTeamMapStatSumAggregateOutputType | null
  _min: MatchTeamMapStatMinAggregateOutputType | null
  _max: MatchTeamMapStatMaxAggregateOutputType | null
}

type GetMatchTeamMapStatGroupByPayload<T extends MatchTeamMapStatGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<MatchTeamMapStatGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof MatchTeamMapStatGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], MatchTeamMapStatGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], MatchTeamMapStatGroupByOutputType[P]>
      }
    >
  >



export type MatchTeamMapStatWhereInput = {
  AND?: Prisma.MatchTeamMapStatWhereInput | Prisma.MatchTeamMapStatWhereInput[]
  OR?: Prisma.MatchTeamMapStatWhereInput[]
  NOT?: Prisma.MatchTeamMapStatWhereInput | Prisma.MatchTeamMapStatWhereInput[]
  score?: Prisma.IntFilter<"MatchTeamMapStat"> | number
  isWinner?: Prisma.BoolFilter<"MatchTeamMapStat"> | boolean
  initialSide?: Prisma.StringFilter<"MatchTeamMapStat"> | string
  matchMapId?: Prisma.UuidFilter<"MatchTeamMapStat"> | string
  matchTeamId?: Prisma.UuidFilter<"MatchTeamMapStat"> | string
  matchMap?: Prisma.XOR<Prisma.MatchMapScalarRelationFilter, Prisma.MatchMapWhereInput>
  matchTeam?: Prisma.XOR<Prisma.MatchTeamScalarRelationFilter, Prisma.MatchTeamWhereInput>
}

export type MatchTeamMapStatOrderByWithRelationInput = {
  score?: Prisma.SortOrder
  isWinner?: Prisma.SortOrder
  initialSide?: Prisma.SortOrder
  matchMapId?: Prisma.SortOrder
  matchTeamId?: Prisma.SortOrder
  matchMap?: Prisma.MatchMapOrderByWithRelationInput
  matchTeam?: Prisma.MatchTeamOrderByWithRelationInput
}

export type MatchTeamMapStatWhereUniqueInput = Prisma.AtLeast<{
  matchMapId_matchTeamId?: Prisma.MatchTeamMapStatMatchMapIdMatchTeamIdCompoundUniqueInput
  AND?: Prisma.MatchTeamMapStatWhereInput | Prisma.MatchTeamMapStatWhereInput[]
  OR?: Prisma.MatchTeamMapStatWhereInput[]
  NOT?: Prisma.MatchTeamMapStatWhereInput | Prisma.MatchTeamMapStatWhereInput[]
  score?: Prisma.IntFilter<"MatchTeamMapStat"> | number
  isWinner?: Prisma.BoolFilter<"MatchTeamMapStat"> | boolean
  initialSide?: Prisma.StringFilter<"MatchTeamMapStat"> | string
  matchMapId?: Prisma.UuidFilter<"MatchTeamMapStat"> | string
  matchTeamId?: Prisma.UuidFilter<"MatchTeamMapStat"> | string
  matchMap?: Prisma.XOR<Prisma.MatchMapScalarRelationFilter, Prisma.MatchMapWhereInput>
  matchTeam?: Prisma.XOR<Prisma.MatchTeamScalarRelationFilter, Prisma.MatchTeamWhereInput>
}, "matchMapId_matchTeamId">

export type MatchTeamMapStatOrderByWithAggregationInput = {
  score?: Prisma.SortOrder
  isWinner?: Prisma.SortOrder
  initialSide?: Prisma.SortOrder
  matchMapId?: Prisma.SortOrder
  matchTeamId?: Prisma.SortOrder
  _count?: Prisma.MatchTeamMapStatCountOrderByAggregateInput
  _avg?: Prisma.MatchTeamMapStatAvgOrderByAggregateInput
  _max?: Prisma.MatchTeamMapStatMaxOrderByAggregateInput
  _min?: Prisma.MatchTeamMapStatMinOrderByAggregateInput
  _sum?: Prisma.MatchTeamMapStatSumOrderByAggregateInput
}

export type MatchTeamMapStatScalarWhereWithAggregatesInput = {
  AND?: Prisma.MatchTeamMapStatScalarWhereWithAggregatesInput | Prisma.MatchTeamMapStatScalarWhereWithAggregatesInput[]
  OR?: Prisma.MatchTeamMapStatScalarWhereWithAggregatesInput[]
  NOT?: Prisma.MatchTeamMapStatScalarWhereWithAggregatesInput | Prisma.MatchTeamMapStatScalarWhereWithAggregatesInput[]
  score?: Prisma.IntWithAggregatesFilter<"MatchTeamMapStat"> | number
  isWinner?: Prisma.BoolWithAggregatesFilter<"MatchTeamMapStat"> | boolean
  initialSide?: Prisma.StringWithAggregatesFilter<"MatchTeamMapStat"> | string
  matchMapId?: Prisma.UuidWithAggregatesFilter<"MatchTeamMapStat"> | string
  matchTeamId?: Prisma.UuidWithAggregatesFilter<"MatchTeamMapStat"> | string
}

export type MatchTeamMapStatCreateInput = {
  score: number
  isWinner: boolean
  initialSide: string
  matchMap: Prisma.MatchMapCreateNestedOneWithoutTeamStatsInput
  matchTeam: Prisma.MatchTeamCreateNestedOneWithoutMapStatsInput
}

export type MatchTeamMapStatUncheckedCreateInput = {
  score: number
  isWinner: boolean
  initialSide: string
  matchMapId: string
  matchTeamId: string
}

export type MatchTeamMapStatUpdateInput = {
  score?: Prisma.IntFieldUpdateOperationsInput | number
  isWinner?: Prisma.BoolFieldUpdateOperationsInput | boolean
  initialSide?: Prisma.StringFieldUpdateOperationsInput | string
  matchMap?: Prisma.MatchMapUpdateOneRequiredWithoutTeamStatsNestedInput
  matchTeam?: Prisma.MatchTeamUpdateOneRequiredWithoutMapStatsNestedInput
}

export type MatchTeamMapStatUncheckedUpdateInput = {
  score?: Prisma.IntFieldUpdateOperationsInput | number
  isWinner?: Prisma.BoolFieldUpdateOperationsInput | boolean
  initialSide?: Prisma.StringFieldUpdateOperationsInput | string
  matchMapId?: Prisma.StringFieldUpdateOperationsInput | string
  matchTeamId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type MatchTeamMapStatCreateManyInput = {
  score: number
  isWinner: boolean
  initialSide: string
  matchMapId: string
  matchTeamId: string
}

export type MatchTeamMapStatUpdateManyMutationInput = {
  score?: Prisma.IntFieldUpdateOperationsInput | number
  isWinner?: Prisma.BoolFieldUpdateOperationsInput | boolean
  initialSide?: Prisma.StringFieldUpdateOperationsInput | string
}

export type MatchTeamMapStatUncheckedUpdateManyInput = {
  score?: Prisma.IntFieldUpdateOperationsInput | number
  isWinner?: Prisma.BoolFieldUpdateOperationsInput | boolean
  initialSide?: Prisma.StringFieldUpdateOperationsInput | string
  matchMapId?: Prisma.StringFieldUpdateOperationsInput | string
  matchTeamId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type MatchTeamMapStatListRelationFilter = {
  every?: Prisma.MatchTeamMapStatWhereInput
  some?: Prisma.MatchTeamMapStatWhereInput
  none?: Prisma.MatchTeamMapStatWhereInput
}

export type MatchTeamMapStatOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type MatchTeamMapStatMatchMapIdMatchTeamIdCompoundUniqueInput = {
  matchMapId: string
  matchTeamId: string
}

export type MatchTeamMapStatCountOrderByAggregateInput = {
  score?: Prisma.SortOrder
  isWinner?: Prisma.SortOrder
  initialSide?: Prisma.SortOrder
  matchMapId?: Prisma.SortOrder
  matchTeamId?: Prisma.SortOrder
}

export type MatchTeamMapStatAvgOrderByAggregateInput = {
  score?: Prisma.SortOrder
}

export type MatchTeamMapStatMaxOrderByAggregateInput = {
  score?: Prisma.SortOrder
  isWinner?: Prisma.SortOrder
  initialSide?: Prisma.SortOrder
  matchMapId?: Prisma.SortOrder
  matchTeamId?: Prisma.SortOrder
}

export type MatchTeamMapStatMinOrderByAggregateInput = {
  score?: Prisma.SortOrder
  isWinner?: Prisma.SortOrder
  initialSide?: Prisma.SortOrder
  matchMapId?: Prisma.SortOrder
  matchTeamId?: Prisma.SortOrder
}

export type MatchTeamMapStatSumOrderByAggregateInput = {
  score?: Prisma.SortOrder
}

export type MatchTeamMapStatCreateNestedManyWithoutMatchMapInput = {
  create?: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchMapInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchMapInput> | Prisma.MatchTeamMapStatCreateWithoutMatchMapInput[] | Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchMapInput[]
  connectOrCreate?: Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchMapInput | Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchMapInput[]
  createMany?: Prisma.MatchTeamMapStatCreateManyMatchMapInputEnvelope
  connect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
}

export type MatchTeamMapStatUncheckedCreateNestedManyWithoutMatchMapInput = {
  create?: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchMapInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchMapInput> | Prisma.MatchTeamMapStatCreateWithoutMatchMapInput[] | Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchMapInput[]
  connectOrCreate?: Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchMapInput | Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchMapInput[]
  createMany?: Prisma.MatchTeamMapStatCreateManyMatchMapInputEnvelope
  connect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
}

export type MatchTeamMapStatUpdateManyWithoutMatchMapNestedInput = {
  create?: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchMapInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchMapInput> | Prisma.MatchTeamMapStatCreateWithoutMatchMapInput[] | Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchMapInput[]
  connectOrCreate?: Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchMapInput | Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchMapInput[]
  upsert?: Prisma.MatchTeamMapStatUpsertWithWhereUniqueWithoutMatchMapInput | Prisma.MatchTeamMapStatUpsertWithWhereUniqueWithoutMatchMapInput[]
  createMany?: Prisma.MatchTeamMapStatCreateManyMatchMapInputEnvelope
  set?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  disconnect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  delete?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  connect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  update?: Prisma.MatchTeamMapStatUpdateWithWhereUniqueWithoutMatchMapInput | Prisma.MatchTeamMapStatUpdateWithWhereUniqueWithoutMatchMapInput[]
  updateMany?: Prisma.MatchTeamMapStatUpdateManyWithWhereWithoutMatchMapInput | Prisma.MatchTeamMapStatUpdateManyWithWhereWithoutMatchMapInput[]
  deleteMany?: Prisma.MatchTeamMapStatScalarWhereInput | Prisma.MatchTeamMapStatScalarWhereInput[]
}

export type MatchTeamMapStatUncheckedUpdateManyWithoutMatchMapNestedInput = {
  create?: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchMapInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchMapInput> | Prisma.MatchTeamMapStatCreateWithoutMatchMapInput[] | Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchMapInput[]
  connectOrCreate?: Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchMapInput | Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchMapInput[]
  upsert?: Prisma.MatchTeamMapStatUpsertWithWhereUniqueWithoutMatchMapInput | Prisma.MatchTeamMapStatUpsertWithWhereUniqueWithoutMatchMapInput[]
  createMany?: Prisma.MatchTeamMapStatCreateManyMatchMapInputEnvelope
  set?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  disconnect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  delete?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  connect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  update?: Prisma.MatchTeamMapStatUpdateWithWhereUniqueWithoutMatchMapInput | Prisma.MatchTeamMapStatUpdateWithWhereUniqueWithoutMatchMapInput[]
  updateMany?: Prisma.MatchTeamMapStatUpdateManyWithWhereWithoutMatchMapInput | Prisma.MatchTeamMapStatUpdateManyWithWhereWithoutMatchMapInput[]
  deleteMany?: Prisma.MatchTeamMapStatScalarWhereInput | Prisma.MatchTeamMapStatScalarWhereInput[]
}

export type MatchTeamMapStatCreateNestedManyWithoutMatchTeamInput = {
  create?: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchTeamInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchTeamInput> | Prisma.MatchTeamMapStatCreateWithoutMatchTeamInput[] | Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchTeamInput[]
  connectOrCreate?: Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchTeamInput | Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchTeamInput[]
  createMany?: Prisma.MatchTeamMapStatCreateManyMatchTeamInputEnvelope
  connect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
}

export type MatchTeamMapStatUncheckedCreateNestedManyWithoutMatchTeamInput = {
  create?: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchTeamInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchTeamInput> | Prisma.MatchTeamMapStatCreateWithoutMatchTeamInput[] | Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchTeamInput[]
  connectOrCreate?: Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchTeamInput | Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchTeamInput[]
  createMany?: Prisma.MatchTeamMapStatCreateManyMatchTeamInputEnvelope
  connect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
}

export type MatchTeamMapStatUpdateManyWithoutMatchTeamNestedInput = {
  create?: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchTeamInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchTeamInput> | Prisma.MatchTeamMapStatCreateWithoutMatchTeamInput[] | Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchTeamInput[]
  connectOrCreate?: Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchTeamInput | Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchTeamInput[]
  upsert?: Prisma.MatchTeamMapStatUpsertWithWhereUniqueWithoutMatchTeamInput | Prisma.MatchTeamMapStatUpsertWithWhereUniqueWithoutMatchTeamInput[]
  createMany?: Prisma.MatchTeamMapStatCreateManyMatchTeamInputEnvelope
  set?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  disconnect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  delete?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  connect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  update?: Prisma.MatchTeamMapStatUpdateWithWhereUniqueWithoutMatchTeamInput | Prisma.MatchTeamMapStatUpdateWithWhereUniqueWithoutMatchTeamInput[]
  updateMany?: Prisma.MatchTeamMapStatUpdateManyWithWhereWithoutMatchTeamInput | Prisma.MatchTeamMapStatUpdateManyWithWhereWithoutMatchTeamInput[]
  deleteMany?: Prisma.MatchTeamMapStatScalarWhereInput | Prisma.MatchTeamMapStatScalarWhereInput[]
}

export type MatchTeamMapStatUncheckedUpdateManyWithoutMatchTeamNestedInput = {
  create?: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchTeamInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchTeamInput> | Prisma.MatchTeamMapStatCreateWithoutMatchTeamInput[] | Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchTeamInput[]
  connectOrCreate?: Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchTeamInput | Prisma.MatchTeamMapStatCreateOrConnectWithoutMatchTeamInput[]
  upsert?: Prisma.MatchTeamMapStatUpsertWithWhereUniqueWithoutMatchTeamInput | Prisma.MatchTeamMapStatUpsertWithWhereUniqueWithoutMatchTeamInput[]
  createMany?: Prisma.MatchTeamMapStatCreateManyMatchTeamInputEnvelope
  set?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  disconnect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  delete?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  connect?: Prisma.MatchTeamMapStatWhereUniqueInput | Prisma.MatchTeamMapStatWhereUniqueInput[]
  update?: Prisma.MatchTeamMapStatUpdateWithWhereUniqueWithoutMatchTeamInput | Prisma.MatchTeamMapStatUpdateWithWhereUniqueWithoutMatchTeamInput[]
  updateMany?: Prisma.MatchTeamMapStatUpdateManyWithWhereWithoutMatchTeamInput | Prisma.MatchTeamMapStatUpdateManyWithWhereWithoutMatchTeamInput[]
  deleteMany?: Prisma.MatchTeamMapStatScalarWhereInput | Prisma.MatchTeamMapStatScalarWhereInput[]
}

export type MatchTeamMapStatCreateWithoutMatchMapInput = {
  score: number
  isWinner: boolean
  initialSide: string
  matchTeam: Prisma.MatchTeamCreateNestedOneWithoutMapStatsInput
}

export type MatchTeamMapStatUncheckedCreateWithoutMatchMapInput = {
  score: number
  isWinner: boolean
  initialSide: string
  matchTeamId: string
}

export type MatchTeamMapStatCreateOrConnectWithoutMatchMapInput = {
  where: Prisma.MatchTeamMapStatWhereUniqueInput
  create: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchMapInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchMapInput>
}

export type MatchTeamMapStatCreateManyMatchMapInputEnvelope = {
  data: Prisma.MatchTeamMapStatCreateManyMatchMapInput | Prisma.MatchTeamMapStatCreateManyMatchMapInput[]
  skipDuplicates?: boolean
}

export type MatchTeamMapStatUpsertWithWhereUniqueWithoutMatchMapInput = {
  where: Prisma.MatchTeamMapStatWhereUniqueInput
  update: Prisma.XOR<Prisma.MatchTeamMapStatUpdateWithoutMatchMapInput, Prisma.MatchTeamMapStatUncheckedUpdateWithoutMatchMapInput>
  create: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchMapInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchMapInput>
}

export type MatchTeamMapStatUpdateWithWhereUniqueWithoutMatchMapInput = {
  where: Prisma.MatchTeamMapStatWhereUniqueInput
  data: Prisma.XOR<Prisma.MatchTeamMapStatUpdateWithoutMatchMapInput, Prisma.MatchTeamMapStatUncheckedUpdateWithoutMatchMapInput>
}

export type MatchTeamMapStatUpdateManyWithWhereWithoutMatchMapInput = {
  where: Prisma.MatchTeamMapStatScalarWhereInput
  data: Prisma.XOR<Prisma.MatchTeamMapStatUpdateManyMutationInput, Prisma.MatchTeamMapStatUncheckedUpdateManyWithoutMatchMapInput>
}

export type MatchTeamMapStatScalarWhereInput = {
  AND?: Prisma.MatchTeamMapStatScalarWhereInput | Prisma.MatchTeamMapStatScalarWhereInput[]
  OR?: Prisma.MatchTeamMapStatScalarWhereInput[]
  NOT?: Prisma.MatchTeamMapStatScalarWhereInput | Prisma.MatchTeamMapStatScalarWhereInput[]
  score?: Prisma.IntFilter<"MatchTeamMapStat"> | number
  isWinner?: Prisma.BoolFilter<"MatchTeamMapStat"> | boolean
  initialSide?: Prisma.StringFilter<"MatchTeamMapStat"> | string
  matchMapId?: Prisma.UuidFilter<"MatchTeamMapStat"> | string
  matchTeamId?: Prisma.UuidFilter<"MatchTeamMapStat"> | string
}

export type MatchTeamMapStatCreateWithoutMatchTeamInput = {
  score: number
  isWinner: boolean
  initialSide: string
  matchMap: Prisma.MatchMapCreateNestedOneWithoutTeamStatsInput
}

export type MatchTeamMapStatUncheckedCreateWithoutMatchTeamInput = {
  score: number
  isWinner: boolean
  initialSide: string
  matchMapId: string
}

export type MatchTeamMapStatCreateOrConnectWithoutMatchTeamInput = {
  where: Prisma.MatchTeamMapStatWhereUniqueInput
  create: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchTeamInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchTeamInput>
}

export type MatchTeamMapStatCreateManyMatchTeamInputEnvelope = {
  data: Prisma.MatchTeamMapStatCreateManyMatchTeamInput | Prisma.MatchTeamMapStatCreateManyMatchTeamInput[]
  skipDuplicates?: boolean
}

export type MatchTeamMapStatUpsertWithWhereUniqueWithoutMatchTeamInput = {
  where: Prisma.MatchTeamMapStatWhereUniqueInput
  update: Prisma.XOR<Prisma.MatchTeamMapStatUpdateWithoutMatchTeamInput, Prisma.MatchTeamMapStatUncheckedUpdateWithoutMatchTeamInput>
  create: Prisma.XOR<Prisma.MatchTeamMapStatCreateWithoutMatchTeamInput, Prisma.MatchTeamMapStatUncheckedCreateWithoutMatchTeamInput>
}

export type MatchTeamMapStatUpdateWithWhereUniqueWithoutMatchTeamInput = {
  where: Prisma.MatchTeamMapStatWhereUniqueInput
  data: Prisma.XOR<Prisma.MatchTeamMapStatUpdateWithoutMatchTeamInput, Prisma.MatchTeamMapStatUncheckedUpdateWithoutMatchTeamInput>
}

export type MatchTeamMapStatUpdateManyWithWhereWithoutMatchTeamInput = {
  where: Prisma.MatchTeamMapStatScalarWhereInput
  data: Prisma.XOR<Prisma.MatchTeamMapStatUpdateManyMutationInput, Prisma.MatchTeamMapStatUncheckedUpdateManyWithoutMatchTeamInput>
}

export type MatchTeamMapStatCreateManyMatchMapInput = {
  score: number
  isWinner: boolean
  initialSide: string
  matchTeamId: string
}

export type MatchTeamMapStatUpdateWithoutMatchMapInput = {
  score?: Prisma.IntFieldUpdateOperationsInput | number
  isWinner?: Prisma.BoolFieldUpdateOperationsInput | boolean
  initialSide?: Prisma.StringFieldUpdateOperationsInput | string
  matchTeam?: Prisma.MatchTeamUpdateOneRequiredWithoutMapStatsNestedInput
}

export type MatchTeamMapStatUncheckedUpdateWithoutMatchMapInput = {
  score?: Prisma.IntFieldUpdateOperationsInput | number
  isWinner?: Prisma.BoolFieldUpdateOperationsInput | boolean
  initialSide?: Prisma.StringFieldUpdateOperationsInput | string
  matchTeamId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type MatchTeamMapStatUncheckedUpdateManyWithoutMatchMapInput = {
  score?: Prisma.IntFieldUpdateOperationsInput | number
  isWinner?: Prisma.BoolFieldUpdateOperationsInput | boolean
  initialSide?: Prisma.StringFieldUpdateOperationsInput | string
  matchTeamId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type MatchTeamMapStatCreateManyMatchTeamInput = {
  score: number
  isWinner: boolean
  initialSide: string
  matchMapId: string
}

export type MatchTeamMapStatUpdateWithoutMatchTeamInput = {
  score?: Prisma.IntFieldUpdateOperationsInput | number
  isWinner?: Prisma.BoolFieldUpdateOperationsInput | boolean
  initialSide?: Prisma.StringFieldUpdateOperationsInput | string
  matchMap?: Prisma.MatchMapUpdateOneRequiredWithoutTeamStatsNestedInput
}

export type MatchTeamMapStatUncheckedUpdateWithoutMatchTeamInput = {
  score?: Prisma.IntFieldUpdateOperationsInput | number
  isWinner?: Prisma.BoolFieldUpdateOperationsInput | boolean
  initialSide?: Prisma.StringFieldUpdateOperationsInput | string
  matchMapId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type MatchTeamMapStatUncheckedUpdateManyWithoutMatchTeamInput = {
  score?: Prisma.IntFieldUpdateOperationsInput | number
  isWinner?: Prisma.BoolFieldUpdateOperationsInput | boolean
  initialSide?: Prisma.StringFieldUpdateOperationsInput | string
  matchMapId?: Prisma.StringFieldUpdateOperationsInput | string
}



export type MatchTeamMapStatSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  score?: boolean
  isWinner?: boolean
  initialSide?: boolean
  matchMapId?: boolean
  matchTeamId?: boolean
  matchMap?: boolean | Prisma.MatchMapDefaultArgs<ExtArgs>
  matchTeam?: boolean | Prisma.MatchTeamDefaultArgs<ExtArgs>
}, ExtArgs["result"]["matchTeamMapStat"]>

export type MatchTeamMapStatSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  score?: boolean
  isWinner?: boolean
  initialSide?: boolean
  matchMapId?: boolean
  matchTeamId?: boolean
  matchMap?: boolean | Prisma.MatchMapDefaultArgs<ExtArgs>
  matchTeam?: boolean | Prisma.MatchTeamDefaultArgs<ExtArgs>
}, ExtArgs["result"]["matchTeamMapStat"]>

export type MatchTeamMapStatSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  score?: boolean
  isWinner?: boolean
  initialSide?: boolean
  matchMapId?: boolean
  matchTeamId?: boolean
  matchMap?: boolean | Prisma.MatchMapDefaultArgs<ExtArgs>
  matchTeam?: boolean | Prisma.MatchTeamDefaultArgs<ExtArgs>
}, ExtArgs["result"]["matchTeamMapStat"]>

export type MatchTeamMapStatSelectScalar = {
  score?: boolean
  isWinner?: boolean
  initialSide?: boolean
  matchMapId?: boolean
  matchTeamId?: boolean
}

export type MatchTeamMapStatOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"score" | "isWinner" | "initialSide" | "matchMapId" | "matchTeamId", ExtArgs["result"]["matchTeamMapStat"]>
export type MatchTeamMapStatInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  matchMap?: boolean | Prisma.MatchMapDefaultArgs<ExtArgs>
  matchTeam?: boolean | Prisma.MatchTeamDefaultArgs<ExtArgs>
}
export type MatchTeamMapStatIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  matchMap?: boolean | Prisma.MatchMapDefaultArgs<ExtArgs>
  matchTeam?: boolean | Prisma.MatchTeamDefaultArgs<ExtArgs>
}
export type MatchTeamMapStatIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  matchMap?: boolean | Prisma.MatchMapDefaultArgs<ExtArgs>
  matchTeam?: boolean | Prisma.MatchTeamDefaultArgs<ExtArgs>
}

export type $MatchTeamMapStatPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "MatchTeamMapStat"
  objects: {
    matchMap: Prisma.$MatchMapPayload<ExtArgs>
    matchTeam: Prisma.$MatchTeamPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    score: number
    isWinner: boolean
    initialSide: string
    matchMapId: string
    matchTeamId: string
  }, ExtArgs["result"]["matchTeamMapStat"]>
  composites: {}
}

export type MatchTeamMapStatGetPayload<S extends boolean | null | undefined | MatchTeamMapStatDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload, S>

export type MatchTeamMapStatCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<MatchTeamMapStatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MatchTeamMapStatCountAggregateInputType | true
  }

export interface MatchTeamMapStatDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchTeamMapStat'], meta: { name: 'MatchTeamMapStat' } }
  /**
   * Find zero or one MatchTeamMapStat that matches the filter.
   * @param {MatchTeamMapStatFindUniqueArgs} args - Arguments to find a MatchTeamMapStat
   * @example
   * // Get one MatchTeamMapStat
   * const matchTeamMapStat = await prisma.matchTeamMapStat.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends MatchTeamMapStatFindUniqueArgs>(args: Prisma.SelectSubset<T, MatchTeamMapStatFindUniqueArgs<ExtArgs>>): Prisma.Prisma__MatchTeamMapStatClient<runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one MatchTeamMapStat that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {MatchTeamMapStatFindUniqueOrThrowArgs} args - Arguments to find a MatchTeamMapStat
   * @example
   * // Get one MatchTeamMapStat
   * const matchTeamMapStat = await prisma.matchTeamMapStat.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends MatchTeamMapStatFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, MatchTeamMapStatFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__MatchTeamMapStatClient<runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first MatchTeamMapStat that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchTeamMapStatFindFirstArgs} args - Arguments to find a MatchTeamMapStat
   * @example
   * // Get one MatchTeamMapStat
   * const matchTeamMapStat = await prisma.matchTeamMapStat.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends MatchTeamMapStatFindFirstArgs>(args?: Prisma.SelectSubset<T, MatchTeamMapStatFindFirstArgs<ExtArgs>>): Prisma.Prisma__MatchTeamMapStatClient<runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first MatchTeamMapStat that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchTeamMapStatFindFirstOrThrowArgs} args - Arguments to find a MatchTeamMapStat
   * @example
   * // Get one MatchTeamMapStat
   * const matchTeamMapStat = await prisma.matchTeamMapStat.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends MatchTeamMapStatFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, MatchTeamMapStatFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__MatchTeamMapStatClient<runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more MatchTeamMapStats that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchTeamMapStatFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all MatchTeamMapStats
   * const matchTeamMapStats = await prisma.matchTeamMapStat.findMany()
   * 
   * // Get first 10 MatchTeamMapStats
   * const matchTeamMapStats = await prisma.matchTeamMapStat.findMany({ take: 10 })
   * 
   * // Only select the `score`
   * const matchTeamMapStatWithScoreOnly = await prisma.matchTeamMapStat.findMany({ select: { score: true } })
   * 
   */
  findMany<T extends MatchTeamMapStatFindManyArgs>(args?: Prisma.SelectSubset<T, MatchTeamMapStatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a MatchTeamMapStat.
   * @param {MatchTeamMapStatCreateArgs} args - Arguments to create a MatchTeamMapStat.
   * @example
   * // Create one MatchTeamMapStat
   * const MatchTeamMapStat = await prisma.matchTeamMapStat.create({
   *   data: {
   *     // ... data to create a MatchTeamMapStat
   *   }
   * })
   * 
   */
  create<T extends MatchTeamMapStatCreateArgs>(args: Prisma.SelectSubset<T, MatchTeamMapStatCreateArgs<ExtArgs>>): Prisma.Prisma__MatchTeamMapStatClient<runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many MatchTeamMapStats.
   * @param {MatchTeamMapStatCreateManyArgs} args - Arguments to create many MatchTeamMapStats.
   * @example
   * // Create many MatchTeamMapStats
   * const matchTeamMapStat = await prisma.matchTeamMapStat.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends MatchTeamMapStatCreateManyArgs>(args?: Prisma.SelectSubset<T, MatchTeamMapStatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many MatchTeamMapStats and returns the data saved in the database.
   * @param {MatchTeamMapStatCreateManyAndReturnArgs} args - Arguments to create many MatchTeamMapStats.
   * @example
   * // Create many MatchTeamMapStats
   * const matchTeamMapStat = await prisma.matchTeamMapStat.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many MatchTeamMapStats and only return the `score`
   * const matchTeamMapStatWithScoreOnly = await prisma.matchTeamMapStat.createManyAndReturn({
   *   select: { score: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends MatchTeamMapStatCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, MatchTeamMapStatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a MatchTeamMapStat.
   * @param {MatchTeamMapStatDeleteArgs} args - Arguments to delete one MatchTeamMapStat.
   * @example
   * // Delete one MatchTeamMapStat
   * const MatchTeamMapStat = await prisma.matchTeamMapStat.delete({
   *   where: {
   *     // ... filter to delete one MatchTeamMapStat
   *   }
   * })
   * 
   */
  delete<T extends MatchTeamMapStatDeleteArgs>(args: Prisma.SelectSubset<T, MatchTeamMapStatDeleteArgs<ExtArgs>>): Prisma.Prisma__MatchTeamMapStatClient<runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one MatchTeamMapStat.
   * @param {MatchTeamMapStatUpdateArgs} args - Arguments to update one MatchTeamMapStat.
   * @example
   * // Update one MatchTeamMapStat
   * const matchTeamMapStat = await prisma.matchTeamMapStat.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends MatchTeamMapStatUpdateArgs>(args: Prisma.SelectSubset<T, MatchTeamMapStatUpdateArgs<ExtArgs>>): Prisma.Prisma__MatchTeamMapStatClient<runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more MatchTeamMapStats.
   * @param {MatchTeamMapStatDeleteManyArgs} args - Arguments to filter MatchTeamMapStats to delete.
   * @example
   * // Delete a few MatchTeamMapStats
   * const { count } = await prisma.matchTeamMapStat.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends MatchTeamMapStatDeleteManyArgs>(args?: Prisma.SelectSubset<T, MatchTeamMapStatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more MatchTeamMapStats.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchTeamMapStatUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many MatchTeamMapStats
   * const matchTeamMapStat = await prisma.matchTeamMapStat.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends MatchTeamMapStatUpdateManyArgs>(args: Prisma.SelectSubset<T, MatchTeamMapStatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more MatchTeamMapStats and returns the data updated in the database.
   * @param {MatchTeamMapStatUpdateManyAndReturnArgs} args - Arguments to update many MatchTeamMapStats.
   * @example
   * // Update many MatchTeamMapStats
   * const matchTeamMapStat = await prisma.matchTeamMapStat.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more MatchTeamMapStats and only return the `score`
   * const matchTeamMapStatWithScoreOnly = await prisma.matchTeamMapStat.updateManyAndReturn({
   *   select: { score: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends MatchTeamMapStatUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, MatchTeamMapStatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one MatchTeamMapStat.
   * @param {MatchTeamMapStatUpsertArgs} args - Arguments to update or create a MatchTeamMapStat.
   * @example
   * // Update or create a MatchTeamMapStat
   * const matchTeamMapStat = await prisma.matchTeamMapStat.upsert({
   *   create: {
   *     // ... data to create a MatchTeamMapStat
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the MatchTeamMapStat we want to update
   *   }
   * })
   */
  upsert<T extends MatchTeamMapStatUpsertArgs>(args: Prisma.SelectSubset<T, MatchTeamMapStatUpsertArgs<ExtArgs>>): Prisma.Prisma__MatchTeamMapStatClient<runtime.Types.Result.GetResult<Prisma.$MatchTeamMapStatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of MatchTeamMapStats.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchTeamMapStatCountArgs} args - Arguments to filter MatchTeamMapStats to count.
   * @example
   * // Count the number of MatchTeamMapStats
   * const count = await prisma.matchTeamMapStat.count({
   *   where: {
   *     // ... the filter for the MatchTeamMapStats we want to count
   *   }
   * })
  **/
  count<T extends MatchTeamMapStatCountArgs>(
    args?: Prisma.Subset<T, MatchTeamMapStatCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], MatchTeamMapStatCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a MatchTeamMapStat.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchTeamMapStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends MatchTeamMapStatAggregateArgs>(args: Prisma.Subset<T, MatchTeamMapStatAggregateArgs>): Prisma.PrismaPromise<GetMatchTeamMapStatAggregateType<T>>

  /**
   * Group by MatchTeamMapStat.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchTeamMapStatGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends MatchTeamMapStatGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: MatchTeamMapStatGroupByArgs['orderBy'] }
      : { orderBy?: MatchTeamMapStatGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, MatchTeamMapStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchTeamMapStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the MatchTeamMapStat model
 */
readonly fields: MatchTeamMapStatFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for MatchTeamMapStat.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__MatchTeamMapStatClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  matchMap<T extends Prisma.MatchMapDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.MatchMapDefaultArgs<ExtArgs>>): Prisma.Prisma__MatchMapClient<runtime.Types.Result.GetResult<Prisma.$MatchMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  matchTeam<T extends Prisma.MatchTeamDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.MatchTeamDefaultArgs<ExtArgs>>): Prisma.Prisma__MatchTeamClient<runtime.Types.Result.GetResult<Prisma.$MatchTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the MatchTeamMapStat model
 */
export interface MatchTeamMapStatFieldRefs {
  readonly score: Prisma.FieldRef<"MatchTeamMapStat", 'Int'>
  readonly isWinner: Prisma.FieldRef<"MatchTeamMapStat", 'Boolean'>
  readonly initialSide: Prisma.FieldRef<"MatchTeamMapStat", 'String'>
  readonly matchMapId: Prisma.FieldRef<"MatchTeamMapStat", 'String'>
  readonly matchTeamId: Prisma.FieldRef<"MatchTeamMapStat", 'String'>
}
    

// Custom InputTypes
/**
 * MatchTeamMapStat findUnique
 */
export type MatchTeamMapStatFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatInclude<ExtArgs> | null
  /**
   * Filter, which MatchTeamMapStat to fetch.
   */
  where: Prisma.MatchTeamMapStatWhereUniqueInput
}

/**
 * MatchTeamMapStat findUniqueOrThrow
 */
export type MatchTeamMapStatFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatInclude<ExtArgs> | null
  /**
   * Filter, which MatchTeamMapStat to fetch.
   */
  where: Prisma.MatchTeamMapStatWhereUniqueInput
}

/**
 * MatchTeamMapStat findFirst
 */
export type MatchTeamMapStatFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatInclude<ExtArgs> | null
  /**
   * Filter, which MatchTeamMapStat to fetch.
   */
  where?: Prisma.MatchTeamMapStatWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MatchTeamMapStats to fetch.
   */
  orderBy?: Prisma.MatchTeamMapStatOrderByWithRelationInput | Prisma.MatchTeamMapStatOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for MatchTeamMapStats.
   */
  cursor?: Prisma.MatchTeamMapStatWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` MatchTeamMapStats from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MatchTeamMapStats.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of MatchTeamMapStats.
   */
  distinct?: Prisma.MatchTeamMapStatScalarFieldEnum | Prisma.MatchTeamMapStatScalarFieldEnum[]
}

/**
 * MatchTeamMapStat findFirstOrThrow
 */
export type MatchTeamMapStatFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatInclude<ExtArgs> | null
  /**
   * Filter, which MatchTeamMapStat to fetch.
   */
  where?: Prisma.MatchTeamMapStatWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MatchTeamMapStats to fetch.
   */
  orderBy?: Prisma.MatchTeamMapStatOrderByWithRelationInput | Prisma.MatchTeamMapStatOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for MatchTeamMapStats.
   */
  cursor?: Prisma.MatchTeamMapStatWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` MatchTeamMapStats from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MatchTeamMapStats.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of MatchTeamMapStats.
   */
  distinct?: Prisma.MatchTeamMapStatScalarFieldEnum | Prisma.MatchTeamMapStatScalarFieldEnum[]
}

/**
 * MatchTeamMapStat findMany
 */
export type MatchTeamMapStatFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatInclude<ExtArgs> | null
  /**
   * Filter, which MatchTeamMapStats to fetch.
   */
  where?: Prisma.MatchTeamMapStatWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MatchTeamMapStats to fetch.
   */
  orderBy?: Prisma.MatchTeamMapStatOrderByWithRelationInput | Prisma.MatchTeamMapStatOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing MatchTeamMapStats.
   */
  cursor?: Prisma.MatchTeamMapStatWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` MatchTeamMapStats from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MatchTeamMapStats.
   */
  skip?: number
  distinct?: Prisma.MatchTeamMapStatScalarFieldEnum | Prisma.MatchTeamMapStatScalarFieldEnum[]
}

/**
 * MatchTeamMapStat create
 */
export type MatchTeamMapStatCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatInclude<ExtArgs> | null
  /**
   * The data needed to create a MatchTeamMapStat.
   */
  data: Prisma.XOR<Prisma.MatchTeamMapStatCreateInput, Prisma.MatchTeamMapStatUncheckedCreateInput>
}

/**
 * MatchTeamMapStat createMany
 */
export type MatchTeamMapStatCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many MatchTeamMapStats.
   */
  data: Prisma.MatchTeamMapStatCreateManyInput | Prisma.MatchTeamMapStatCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * MatchTeamMapStat createManyAndReturn
 */
export type MatchTeamMapStatCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * The data used to create many MatchTeamMapStats.
   */
  data: Prisma.MatchTeamMapStatCreateManyInput | Prisma.MatchTeamMapStatCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * MatchTeamMapStat update
 */
export type MatchTeamMapStatUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatInclude<ExtArgs> | null
  /**
   * The data needed to update a MatchTeamMapStat.
   */
  data: Prisma.XOR<Prisma.MatchTeamMapStatUpdateInput, Prisma.MatchTeamMapStatUncheckedUpdateInput>
  /**
   * Choose, which MatchTeamMapStat to update.
   */
  where: Prisma.MatchTeamMapStatWhereUniqueInput
}

/**
 * MatchTeamMapStat updateMany
 */
export type MatchTeamMapStatUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update MatchTeamMapStats.
   */
  data: Prisma.XOR<Prisma.MatchTeamMapStatUpdateManyMutationInput, Prisma.MatchTeamMapStatUncheckedUpdateManyInput>
  /**
   * Filter which MatchTeamMapStats to update
   */
  where?: Prisma.MatchTeamMapStatWhereInput
  /**
   * Limit how many MatchTeamMapStats to update.
   */
  limit?: number
}

/**
 * MatchTeamMapStat updateManyAndReturn
 */
export type MatchTeamMapStatUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * The data used to update MatchTeamMapStats.
   */
  data: Prisma.XOR<Prisma.MatchTeamMapStatUpdateManyMutationInput, Prisma.MatchTeamMapStatUncheckedUpdateManyInput>
  /**
   * Filter which MatchTeamMapStats to update
   */
  where?: Prisma.MatchTeamMapStatWhereInput
  /**
   * Limit how many MatchTeamMapStats to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * MatchTeamMapStat upsert
 */
export type MatchTeamMapStatUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatInclude<ExtArgs> | null
  /**
   * The filter to search for the MatchTeamMapStat to update in case it exists.
   */
  where: Prisma.MatchTeamMapStatWhereUniqueInput
  /**
   * In case the MatchTeamMapStat found by the `where` argument doesn't exist, create a new MatchTeamMapStat with this data.
   */
  create: Prisma.XOR<Prisma.MatchTeamMapStatCreateInput, Prisma.MatchTeamMapStatUncheckedCreateInput>
  /**
   * In case the MatchTeamMapStat was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.MatchTeamMapStatUpdateInput, Prisma.MatchTeamMapStatUncheckedUpdateInput>
}

/**
 * MatchTeamMapStat delete
 */
export type MatchTeamMapStatDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatInclude<ExtArgs> | null
  /**
   * Filter which MatchTeamMapStat to delete.
   */
  where: Prisma.MatchTeamMapStatWhereUniqueInput
}

/**
 * MatchTeamMapStat deleteMany
 */
export type MatchTeamMapStatDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which MatchTeamMapStats to delete
   */
  where?: Prisma.MatchTeamMapStatWhereInput
  /**
   * Limit how many MatchTeamMapStats to delete.
   */
  limit?: number
}

/**
 * MatchTeamMapStat without action
 */
export type MatchTeamMapStatDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchTeamMapStat
   */
  select?: Prisma.MatchTeamMapStatSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchTeamMapStat
   */
  omit?: Prisma.MatchTeamMapStatOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchTeamMapStatInclude<ExtArgs> | null
}
