
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `MatchDamage` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model MatchDamage
 * 
 */
export type MatchDamageModel = runtime.Types.Result.DefaultSelection<Prisma.$MatchDamagePayload>

export type AggregateMatchDamage = {
  _count: MatchDamageCountAggregateOutputType | null
  _avg: MatchDamageAvgAggregateOutputType | null
  _sum: MatchDamageSumAggregateOutputType | null
  _min: MatchDamageMinAggregateOutputType | null
  _max: MatchDamageMaxAggregateOutputType | null
}

export type MatchDamageAvgAggregateOutputType = {
  inflictorId: number | null
  victimId: number | null
  inflictorTeam: number | null
  weaponId: number | null
  damageReal: number | null
  damageNormalized: number | null
  hits: number | null
  tick: number | null
}

export type MatchDamageSumAggregateOutputType = {
  inflictorId: number | null
  victimId: number | null
  inflictorTeam: number | null
  weaponId: number | null
  damageReal: number | null
  damageNormalized: number | null
  hits: number | null
  tick: number | null
}

export type MatchDamageMinAggregateOutputType = {
  id: string | null
  inflictorId: number | null
  victimId: number | null
  inflictorTeam: number | null
  weaponId: number | null
  hitboxGroup: string | null
  damageReal: number | null
  damageNormalized: number | null
  hits: number | null
  matchId: string | null
  roundId: string | null
  tick: number | null
}

export type MatchDamageMaxAggregateOutputType = {
  id: string | null
  inflictorId: number | null
  victimId: number | null
  inflictorTeam: number | null
  weaponId: number | null
  hitboxGroup: string | null
  damageReal: number | null
  damageNormalized: number | null
  hits: number | null
  matchId: string | null
  roundId: string | null
  tick: number | null
}

export type MatchDamageCountAggregateOutputType = {
  id: number
  inflictorId: number
  victimId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: number
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: number
  roundId: number
  tick: number
  _all: number
}


export type MatchDamageAvgAggregateInputType = {
  inflictorId?: true
  victimId?: true
  inflictorTeam?: true
  weaponId?: true
  damageReal?: true
  damageNormalized?: true
  hits?: true
  tick?: true
}

export type MatchDamageSumAggregateInputType = {
  inflictorId?: true
  victimId?: true
  inflictorTeam?: true
  weaponId?: true
  damageReal?: true
  damageNormalized?: true
  hits?: true
  tick?: true
}

export type MatchDamageMinAggregateInputType = {
  id?: true
  inflictorId?: true
  victimId?: true
  inflictorTeam?: true
  weaponId?: true
  hitboxGroup?: true
  damageReal?: true
  damageNormalized?: true
  hits?: true
  matchId?: true
  roundId?: true
  tick?: true
}

export type MatchDamageMaxAggregateInputType = {
  id?: true
  inflictorId?: true
  victimId?: true
  inflictorTeam?: true
  weaponId?: true
  hitboxGroup?: true
  damageReal?: true
  damageNormalized?: true
  hits?: true
  matchId?: true
  roundId?: true
  tick?: true
}

export type MatchDamageCountAggregateInputType = {
  id?: true
  inflictorId?: true
  victimId?: true
  inflictorTeam?: true
  weaponId?: true
  hitboxGroup?: true
  damageReal?: true
  damageNormalized?: true
  hits?: true
  matchId?: true
  roundId?: true
  tick?: true
  _all?: true
}

export type MatchDamageAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which MatchDamage to aggregate.
   */
  where?: Prisma.MatchDamageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MatchDamages to fetch.
   */
  orderBy?: Prisma.MatchDamageOrderByWithRelationInput | Prisma.MatchDamageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.MatchDamageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` MatchDamages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MatchDamages.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned MatchDamages
  **/
  _count?: true | MatchDamageCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: MatchDamageAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: MatchDamageSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: MatchDamageMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: MatchDamageMaxAggregateInputType
}

export type GetMatchDamageAggregateType<T extends MatchDamageAggregateArgs> = {
      [P in keyof T & keyof AggregateMatchDamage]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateMatchDamage[P]>
    : Prisma.GetScalarType<T[P], AggregateMatchDamage[P]>
}




export type MatchDamageGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.MatchDamageWhereInput
  orderBy?: Prisma.MatchDamageOrderByWithAggregationInput | Prisma.MatchDamageOrderByWithAggregationInput[]
  by: Prisma.MatchDamageScalarFieldEnum[] | Prisma.MatchDamageScalarFieldEnum
  having?: Prisma.MatchDamageScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: MatchDamageCountAggregateInputType | true
  _avg?: MatchDamageAvgAggregateInputType
  _sum?: MatchDamageSumAggregateInputType
  _min?: MatchDamageMinAggregateInputType
  _max?: MatchDamageMaxAggregateInputType
}

export type MatchDamageGroupByOutputType = {
  id: string
  inflictorId: number
  victimId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: string
  roundId: string
  tick: number | null
  _count: MatchDamageCountAggregateOutputType | null
  _avg: MatchDamageAvgAggregateOutputType | null
  _sum: MatchDamageSumAggregateOutputType | null
  _min: MatchDamageMinAggregateOutputType | null
  _max: MatchDamageMaxAggregateOutputType | null
}

type GetMatchDamageGroupByPayload<T extends MatchDamageGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<MatchDamageGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof MatchDamageGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], MatchDamageGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], MatchDamageGroupByOutputType[P]>
      }
    >
  >



export type MatchDamageWhereInput = {
  AND?: Prisma.MatchDamageWhereInput | Prisma.MatchDamageWhereInput[]
  OR?: Prisma.MatchDamageWhereInput[]
  NOT?: Prisma.MatchDamageWhereInput | Prisma.MatchDamageWhereInput[]
  id?: Prisma.UuidFilter<"MatchDamage"> | string
  inflictorId?: Prisma.IntFilter<"MatchDamage"> | number
  victimId?: Prisma.IntFilter<"MatchDamage"> | number
  inflictorTeam?: Prisma.IntFilter<"MatchDamage"> | number
  weaponId?: Prisma.IntFilter<"MatchDamage"> | number
  hitboxGroup?: Prisma.StringFilter<"MatchDamage"> | string
  damageReal?: Prisma.IntFilter<"MatchDamage"> | number
  damageNormalized?: Prisma.IntFilter<"MatchDamage"> | number
  hits?: Prisma.IntFilter<"MatchDamage"> | number
  matchId?: Prisma.UuidFilter<"MatchDamage"> | string
  roundId?: Prisma.UuidFilter<"MatchDamage"> | string
  tick?: Prisma.FloatNullableFilter<"MatchDamage"> | number | null
  match?: Prisma.XOR<Prisma.MatchScalarRelationFilter, Prisma.MatchWhereInput>
  round?: Prisma.XOR<Prisma.RoundScalarRelationFilter, Prisma.RoundWhereInput>
  weapon?: Prisma.XOR<Prisma.WeaponScalarRelationFilter, Prisma.WeaponWhereInput>
  inflictor?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
  victim?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
}

export type MatchDamageOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  inflictorId?: Prisma.SortOrder
  victimId?: Prisma.SortOrder
  inflictorTeam?: Prisma.SortOrder
  weaponId?: Prisma.SortOrder
  hitboxGroup?: Prisma.SortOrder
  damageReal?: Prisma.SortOrder
  damageNormalized?: Prisma.SortOrder
  hits?: Prisma.SortOrder
  matchId?: Prisma.SortOrder
  roundId?: Prisma.SortOrder
  tick?: Prisma.SortOrderInput | Prisma.SortOrder
  match?: Prisma.MatchOrderByWithRelationInput
  round?: Prisma.RoundOrderByWithRelationInput
  weapon?: Prisma.WeaponOrderByWithRelationInput
  inflictor?: Prisma.UserOrderByWithRelationInput
  victim?: Prisma.UserOrderByWithRelationInput
}

export type MatchDamageWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.MatchDamageWhereInput | Prisma.MatchDamageWhereInput[]
  OR?: Prisma.MatchDamageWhereInput[]
  NOT?: Prisma.MatchDamageWhereInput | Prisma.MatchDamageWhereInput[]
  inflictorId?: Prisma.IntFilter<"MatchDamage"> | number
  victimId?: Prisma.IntFilter<"MatchDamage"> | number
  inflictorTeam?: Prisma.IntFilter<"MatchDamage"> | number
  weaponId?: Prisma.IntFilter<"MatchDamage"> | number
  hitboxGroup?: Prisma.StringFilter<"MatchDamage"> | string
  damageReal?: Prisma.IntFilter<"MatchDamage"> | number
  damageNormalized?: Prisma.IntFilter<"MatchDamage"> | number
  hits?: Prisma.IntFilter<"MatchDamage"> | number
  matchId?: Prisma.UuidFilter<"MatchDamage"> | string
  roundId?: Prisma.UuidFilter<"MatchDamage"> | string
  tick?: Prisma.FloatNullableFilter<"MatchDamage"> | number | null
  match?: Prisma.XOR<Prisma.MatchScalarRelationFilter, Prisma.MatchWhereInput>
  round?: Prisma.XOR<Prisma.RoundScalarRelationFilter, Prisma.RoundWhereInput>
  weapon?: Prisma.XOR<Prisma.WeaponScalarRelationFilter, Prisma.WeaponWhereInput>
  inflictor?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
  victim?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
}, "id">

export type MatchDamageOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  inflictorId?: Prisma.SortOrder
  victimId?: Prisma.SortOrder
  inflictorTeam?: Prisma.SortOrder
  weaponId?: Prisma.SortOrder
  hitboxGroup?: Prisma.SortOrder
  damageReal?: Prisma.SortOrder
  damageNormalized?: Prisma.SortOrder
  hits?: Prisma.SortOrder
  matchId?: Prisma.SortOrder
  roundId?: Prisma.SortOrder
  tick?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.MatchDamageCountOrderByAggregateInput
  _avg?: Prisma.MatchDamageAvgOrderByAggregateInput
  _max?: Prisma.MatchDamageMaxOrderByAggregateInput
  _min?: Prisma.MatchDamageMinOrderByAggregateInput
  _sum?: Prisma.MatchDamageSumOrderByAggregateInput
}

export type MatchDamageScalarWhereWithAggregatesInput = {
  AND?: Prisma.MatchDamageScalarWhereWithAggregatesInput | Prisma.MatchDamageScalarWhereWithAggregatesInput[]
  OR?: Prisma.MatchDamageScalarWhereWithAggregatesInput[]
  NOT?: Prisma.MatchDamageScalarWhereWithAggregatesInput | Prisma.MatchDamageScalarWhereWithAggregatesInput[]
  id?: Prisma.UuidWithAggregatesFilter<"MatchDamage"> | string
  inflictorId?: Prisma.IntWithAggregatesFilter<"MatchDamage"> | number
  victimId?: Prisma.IntWithAggregatesFilter<"MatchDamage"> | number
  inflictorTeam?: Prisma.IntWithAggregatesFilter<"MatchDamage"> | number
  weaponId?: Prisma.IntWithAggregatesFilter<"MatchDamage"> | number
  hitboxGroup?: Prisma.StringWithAggregatesFilter<"MatchDamage"> | string
  damageReal?: Prisma.IntWithAggregatesFilter<"MatchDamage"> | number
  damageNormalized?: Prisma.IntWithAggregatesFilter<"MatchDamage"> | number
  hits?: Prisma.IntWithAggregatesFilter<"MatchDamage"> | number
  matchId?: Prisma.UuidWithAggregatesFilter<"MatchDamage"> | string
  roundId?: Prisma.UuidWithAggregatesFilter<"MatchDamage"> | string
  tick?: Prisma.FloatNullableWithAggregatesFilter<"MatchDamage"> | number | null
}

export type MatchDamageCreateInput = {
  id?: string
  inflictorTeam: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  tick?: number | null
  match: Prisma.MatchCreateNestedOneWithoutDamagesInput
  round: Prisma.RoundCreateNestedOneWithoutDamagesInput
  weapon: Prisma.WeaponCreateNestedOneWithoutMatchDamageInput
  inflictor?: Prisma.UserCreateNestedOneWithoutDamagesAsInflictorInput
  victim?: Prisma.UserCreateNestedOneWithoutDamagesAsVictimInput
}

export type MatchDamageUncheckedCreateInput = {
  id?: string
  inflictorId: number
  victimId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: string
  roundId: string
  tick?: number | null
}

export type MatchDamageUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  match?: Prisma.MatchUpdateOneRequiredWithoutDamagesNestedInput
  round?: Prisma.RoundUpdateOneRequiredWithoutDamagesNestedInput
  weapon?: Prisma.WeaponUpdateOneRequiredWithoutMatchDamageNestedInput
  inflictor?: Prisma.UserUpdateOneWithoutDamagesAsInflictorNestedInput
  victim?: Prisma.UserUpdateOneWithoutDamagesAsVictimNestedInput
}

export type MatchDamageUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorId?: Prisma.IntFieldUpdateOperationsInput | number
  victimId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  weaponId?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  matchId?: Prisma.StringFieldUpdateOperationsInput | string
  roundId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageCreateManyInput = {
  id?: string
  inflictorId: number
  victimId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: string
  roundId: string
  tick?: number | null
}

export type MatchDamageUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorId?: Prisma.IntFieldUpdateOperationsInput | number
  victimId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  weaponId?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  matchId?: Prisma.StringFieldUpdateOperationsInput | string
  roundId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageListRelationFilter = {
  every?: Prisma.MatchDamageWhereInput
  some?: Prisma.MatchDamageWhereInput
  none?: Prisma.MatchDamageWhereInput
}

export type MatchDamageOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type MatchDamageCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  inflictorId?: Prisma.SortOrder
  victimId?: Prisma.SortOrder
  inflictorTeam?: Prisma.SortOrder
  weaponId?: Prisma.SortOrder
  hitboxGroup?: Prisma.SortOrder
  damageReal?: Prisma.SortOrder
  damageNormalized?: Prisma.SortOrder
  hits?: Prisma.SortOrder
  matchId?: Prisma.SortOrder
  roundId?: Prisma.SortOrder
  tick?: Prisma.SortOrder
}

export type MatchDamageAvgOrderByAggregateInput = {
  inflictorId?: Prisma.SortOrder
  victimId?: Prisma.SortOrder
  inflictorTeam?: Prisma.SortOrder
  weaponId?: Prisma.SortOrder
  damageReal?: Prisma.SortOrder
  damageNormalized?: Prisma.SortOrder
  hits?: Prisma.SortOrder
  tick?: Prisma.SortOrder
}

export type MatchDamageMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  inflictorId?: Prisma.SortOrder
  victimId?: Prisma.SortOrder
  inflictorTeam?: Prisma.SortOrder
  weaponId?: Prisma.SortOrder
  hitboxGroup?: Prisma.SortOrder
  damageReal?: Prisma.SortOrder
  damageNormalized?: Prisma.SortOrder
  hits?: Prisma.SortOrder
  matchId?: Prisma.SortOrder
  roundId?: Prisma.SortOrder
  tick?: Prisma.SortOrder
}

export type MatchDamageMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  inflictorId?: Prisma.SortOrder
  victimId?: Prisma.SortOrder
  inflictorTeam?: Prisma.SortOrder
  weaponId?: Prisma.SortOrder
  hitboxGroup?: Prisma.SortOrder
  damageReal?: Prisma.SortOrder
  damageNormalized?: Prisma.SortOrder
  hits?: Prisma.SortOrder
  matchId?: Prisma.SortOrder
  roundId?: Prisma.SortOrder
  tick?: Prisma.SortOrder
}

export type MatchDamageSumOrderByAggregateInput = {
  inflictorId?: Prisma.SortOrder
  victimId?: Prisma.SortOrder
  inflictorTeam?: Prisma.SortOrder
  weaponId?: Prisma.SortOrder
  damageReal?: Prisma.SortOrder
  damageNormalized?: Prisma.SortOrder
  hits?: Prisma.SortOrder
  tick?: Prisma.SortOrder
}

export type MatchDamageCreateNestedManyWithoutMatchInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutMatchInput, Prisma.MatchDamageUncheckedCreateWithoutMatchInput> | Prisma.MatchDamageCreateWithoutMatchInput[] | Prisma.MatchDamageUncheckedCreateWithoutMatchInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutMatchInput | Prisma.MatchDamageCreateOrConnectWithoutMatchInput[]
  createMany?: Prisma.MatchDamageCreateManyMatchInputEnvelope
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
}

export type MatchDamageUncheckedCreateNestedManyWithoutMatchInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutMatchInput, Prisma.MatchDamageUncheckedCreateWithoutMatchInput> | Prisma.MatchDamageCreateWithoutMatchInput[] | Prisma.MatchDamageUncheckedCreateWithoutMatchInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutMatchInput | Prisma.MatchDamageCreateOrConnectWithoutMatchInput[]
  createMany?: Prisma.MatchDamageCreateManyMatchInputEnvelope
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
}

export type MatchDamageUpdateManyWithoutMatchNestedInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutMatchInput, Prisma.MatchDamageUncheckedCreateWithoutMatchInput> | Prisma.MatchDamageCreateWithoutMatchInput[] | Prisma.MatchDamageUncheckedCreateWithoutMatchInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutMatchInput | Prisma.MatchDamageCreateOrConnectWithoutMatchInput[]
  upsert?: Prisma.MatchDamageUpsertWithWhereUniqueWithoutMatchInput | Prisma.MatchDamageUpsertWithWhereUniqueWithoutMatchInput[]
  createMany?: Prisma.MatchDamageCreateManyMatchInputEnvelope
  set?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  disconnect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  delete?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  update?: Prisma.MatchDamageUpdateWithWhereUniqueWithoutMatchInput | Prisma.MatchDamageUpdateWithWhereUniqueWithoutMatchInput[]
  updateMany?: Prisma.MatchDamageUpdateManyWithWhereWithoutMatchInput | Prisma.MatchDamageUpdateManyWithWhereWithoutMatchInput[]
  deleteMany?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
}

export type MatchDamageUncheckedUpdateManyWithoutMatchNestedInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutMatchInput, Prisma.MatchDamageUncheckedCreateWithoutMatchInput> | Prisma.MatchDamageCreateWithoutMatchInput[] | Prisma.MatchDamageUncheckedCreateWithoutMatchInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutMatchInput | Prisma.MatchDamageCreateOrConnectWithoutMatchInput[]
  upsert?: Prisma.MatchDamageUpsertWithWhereUniqueWithoutMatchInput | Prisma.MatchDamageUpsertWithWhereUniqueWithoutMatchInput[]
  createMany?: Prisma.MatchDamageCreateManyMatchInputEnvelope
  set?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  disconnect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  delete?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  update?: Prisma.MatchDamageUpdateWithWhereUniqueWithoutMatchInput | Prisma.MatchDamageUpdateWithWhereUniqueWithoutMatchInput[]
  updateMany?: Prisma.MatchDamageUpdateManyWithWhereWithoutMatchInput | Prisma.MatchDamageUpdateManyWithWhereWithoutMatchInput[]
  deleteMany?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
}

export type MatchDamageCreateNestedManyWithoutInflictorInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutInflictorInput, Prisma.MatchDamageUncheckedCreateWithoutInflictorInput> | Prisma.MatchDamageCreateWithoutInflictorInput[] | Prisma.MatchDamageUncheckedCreateWithoutInflictorInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutInflictorInput | Prisma.MatchDamageCreateOrConnectWithoutInflictorInput[]
  createMany?: Prisma.MatchDamageCreateManyInflictorInputEnvelope
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
}

export type MatchDamageCreateNestedManyWithoutVictimInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutVictimInput, Prisma.MatchDamageUncheckedCreateWithoutVictimInput> | Prisma.MatchDamageCreateWithoutVictimInput[] | Prisma.MatchDamageUncheckedCreateWithoutVictimInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutVictimInput | Prisma.MatchDamageCreateOrConnectWithoutVictimInput[]
  createMany?: Prisma.MatchDamageCreateManyVictimInputEnvelope
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
}

export type MatchDamageUncheckedCreateNestedManyWithoutInflictorInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutInflictorInput, Prisma.MatchDamageUncheckedCreateWithoutInflictorInput> | Prisma.MatchDamageCreateWithoutInflictorInput[] | Prisma.MatchDamageUncheckedCreateWithoutInflictorInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutInflictorInput | Prisma.MatchDamageCreateOrConnectWithoutInflictorInput[]
  createMany?: Prisma.MatchDamageCreateManyInflictorInputEnvelope
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
}

export type MatchDamageUncheckedCreateNestedManyWithoutVictimInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutVictimInput, Prisma.MatchDamageUncheckedCreateWithoutVictimInput> | Prisma.MatchDamageCreateWithoutVictimInput[] | Prisma.MatchDamageUncheckedCreateWithoutVictimInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutVictimInput | Prisma.MatchDamageCreateOrConnectWithoutVictimInput[]
  createMany?: Prisma.MatchDamageCreateManyVictimInputEnvelope
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
}

export type MatchDamageUpdateManyWithoutInflictorNestedInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutInflictorInput, Prisma.MatchDamageUncheckedCreateWithoutInflictorInput> | Prisma.MatchDamageCreateWithoutInflictorInput[] | Prisma.MatchDamageUncheckedCreateWithoutInflictorInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutInflictorInput | Prisma.MatchDamageCreateOrConnectWithoutInflictorInput[]
  upsert?: Prisma.MatchDamageUpsertWithWhereUniqueWithoutInflictorInput | Prisma.MatchDamageUpsertWithWhereUniqueWithoutInflictorInput[]
  createMany?: Prisma.MatchDamageCreateManyInflictorInputEnvelope
  set?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  disconnect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  delete?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  update?: Prisma.MatchDamageUpdateWithWhereUniqueWithoutInflictorInput | Prisma.MatchDamageUpdateWithWhereUniqueWithoutInflictorInput[]
  updateMany?: Prisma.MatchDamageUpdateManyWithWhereWithoutInflictorInput | Prisma.MatchDamageUpdateManyWithWhereWithoutInflictorInput[]
  deleteMany?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
}

export type MatchDamageUpdateManyWithoutVictimNestedInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutVictimInput, Prisma.MatchDamageUncheckedCreateWithoutVictimInput> | Prisma.MatchDamageCreateWithoutVictimInput[] | Prisma.MatchDamageUncheckedCreateWithoutVictimInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutVictimInput | Prisma.MatchDamageCreateOrConnectWithoutVictimInput[]
  upsert?: Prisma.MatchDamageUpsertWithWhereUniqueWithoutVictimInput | Prisma.MatchDamageUpsertWithWhereUniqueWithoutVictimInput[]
  createMany?: Prisma.MatchDamageCreateManyVictimInputEnvelope
  set?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  disconnect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  delete?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  update?: Prisma.MatchDamageUpdateWithWhereUniqueWithoutVictimInput | Prisma.MatchDamageUpdateWithWhereUniqueWithoutVictimInput[]
  updateMany?: Prisma.MatchDamageUpdateManyWithWhereWithoutVictimInput | Prisma.MatchDamageUpdateManyWithWhereWithoutVictimInput[]
  deleteMany?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
}

export type MatchDamageUncheckedUpdateManyWithoutInflictorNestedInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutInflictorInput, Prisma.MatchDamageUncheckedCreateWithoutInflictorInput> | Prisma.MatchDamageCreateWithoutInflictorInput[] | Prisma.MatchDamageUncheckedCreateWithoutInflictorInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutInflictorInput | Prisma.MatchDamageCreateOrConnectWithoutInflictorInput[]
  upsert?: Prisma.MatchDamageUpsertWithWhereUniqueWithoutInflictorInput | Prisma.MatchDamageUpsertWithWhereUniqueWithoutInflictorInput[]
  createMany?: Prisma.MatchDamageCreateManyInflictorInputEnvelope
  set?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  disconnect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  delete?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  update?: Prisma.MatchDamageUpdateWithWhereUniqueWithoutInflictorInput | Prisma.MatchDamageUpdateWithWhereUniqueWithoutInflictorInput[]
  updateMany?: Prisma.MatchDamageUpdateManyWithWhereWithoutInflictorInput | Prisma.MatchDamageUpdateManyWithWhereWithoutInflictorInput[]
  deleteMany?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
}

export type MatchDamageUncheckedUpdateManyWithoutVictimNestedInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutVictimInput, Prisma.MatchDamageUncheckedCreateWithoutVictimInput> | Prisma.MatchDamageCreateWithoutVictimInput[] | Prisma.MatchDamageUncheckedCreateWithoutVictimInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutVictimInput | Prisma.MatchDamageCreateOrConnectWithoutVictimInput[]
  upsert?: Prisma.MatchDamageUpsertWithWhereUniqueWithoutVictimInput | Prisma.MatchDamageUpsertWithWhereUniqueWithoutVictimInput[]
  createMany?: Prisma.MatchDamageCreateManyVictimInputEnvelope
  set?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  disconnect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  delete?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  update?: Prisma.MatchDamageUpdateWithWhereUniqueWithoutVictimInput | Prisma.MatchDamageUpdateWithWhereUniqueWithoutVictimInput[]
  updateMany?: Prisma.MatchDamageUpdateManyWithWhereWithoutVictimInput | Prisma.MatchDamageUpdateManyWithWhereWithoutVictimInput[]
  deleteMany?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
}

export type MatchDamageCreateNestedManyWithoutRoundInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutRoundInput, Prisma.MatchDamageUncheckedCreateWithoutRoundInput> | Prisma.MatchDamageCreateWithoutRoundInput[] | Prisma.MatchDamageUncheckedCreateWithoutRoundInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutRoundInput | Prisma.MatchDamageCreateOrConnectWithoutRoundInput[]
  createMany?: Prisma.MatchDamageCreateManyRoundInputEnvelope
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
}

export type MatchDamageUncheckedCreateNestedManyWithoutRoundInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutRoundInput, Prisma.MatchDamageUncheckedCreateWithoutRoundInput> | Prisma.MatchDamageCreateWithoutRoundInput[] | Prisma.MatchDamageUncheckedCreateWithoutRoundInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutRoundInput | Prisma.MatchDamageCreateOrConnectWithoutRoundInput[]
  createMany?: Prisma.MatchDamageCreateManyRoundInputEnvelope
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
}

export type MatchDamageUpdateManyWithoutRoundNestedInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutRoundInput, Prisma.MatchDamageUncheckedCreateWithoutRoundInput> | Prisma.MatchDamageCreateWithoutRoundInput[] | Prisma.MatchDamageUncheckedCreateWithoutRoundInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutRoundInput | Prisma.MatchDamageCreateOrConnectWithoutRoundInput[]
  upsert?: Prisma.MatchDamageUpsertWithWhereUniqueWithoutRoundInput | Prisma.MatchDamageUpsertWithWhereUniqueWithoutRoundInput[]
  createMany?: Prisma.MatchDamageCreateManyRoundInputEnvelope
  set?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  disconnect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  delete?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  update?: Prisma.MatchDamageUpdateWithWhereUniqueWithoutRoundInput | Prisma.MatchDamageUpdateWithWhereUniqueWithoutRoundInput[]
  updateMany?: Prisma.MatchDamageUpdateManyWithWhereWithoutRoundInput | Prisma.MatchDamageUpdateManyWithWhereWithoutRoundInput[]
  deleteMany?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
}

export type MatchDamageUncheckedUpdateManyWithoutRoundNestedInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutRoundInput, Prisma.MatchDamageUncheckedCreateWithoutRoundInput> | Prisma.MatchDamageCreateWithoutRoundInput[] | Prisma.MatchDamageUncheckedCreateWithoutRoundInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutRoundInput | Prisma.MatchDamageCreateOrConnectWithoutRoundInput[]
  upsert?: Prisma.MatchDamageUpsertWithWhereUniqueWithoutRoundInput | Prisma.MatchDamageUpsertWithWhereUniqueWithoutRoundInput[]
  createMany?: Prisma.MatchDamageCreateManyRoundInputEnvelope
  set?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  disconnect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  delete?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  update?: Prisma.MatchDamageUpdateWithWhereUniqueWithoutRoundInput | Prisma.MatchDamageUpdateWithWhereUniqueWithoutRoundInput[]
  updateMany?: Prisma.MatchDamageUpdateManyWithWhereWithoutRoundInput | Prisma.MatchDamageUpdateManyWithWhereWithoutRoundInput[]
  deleteMany?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
}

export type MatchDamageCreateNestedManyWithoutWeaponInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutWeaponInput, Prisma.MatchDamageUncheckedCreateWithoutWeaponInput> | Prisma.MatchDamageCreateWithoutWeaponInput[] | Prisma.MatchDamageUncheckedCreateWithoutWeaponInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutWeaponInput | Prisma.MatchDamageCreateOrConnectWithoutWeaponInput[]
  createMany?: Prisma.MatchDamageCreateManyWeaponInputEnvelope
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
}

export type MatchDamageUncheckedCreateNestedManyWithoutWeaponInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutWeaponInput, Prisma.MatchDamageUncheckedCreateWithoutWeaponInput> | Prisma.MatchDamageCreateWithoutWeaponInput[] | Prisma.MatchDamageUncheckedCreateWithoutWeaponInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutWeaponInput | Prisma.MatchDamageCreateOrConnectWithoutWeaponInput[]
  createMany?: Prisma.MatchDamageCreateManyWeaponInputEnvelope
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
}

export type MatchDamageUpdateManyWithoutWeaponNestedInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutWeaponInput, Prisma.MatchDamageUncheckedCreateWithoutWeaponInput> | Prisma.MatchDamageCreateWithoutWeaponInput[] | Prisma.MatchDamageUncheckedCreateWithoutWeaponInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutWeaponInput | Prisma.MatchDamageCreateOrConnectWithoutWeaponInput[]
  upsert?: Prisma.MatchDamageUpsertWithWhereUniqueWithoutWeaponInput | Prisma.MatchDamageUpsertWithWhereUniqueWithoutWeaponInput[]
  createMany?: Prisma.MatchDamageCreateManyWeaponInputEnvelope
  set?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  disconnect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  delete?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  update?: Prisma.MatchDamageUpdateWithWhereUniqueWithoutWeaponInput | Prisma.MatchDamageUpdateWithWhereUniqueWithoutWeaponInput[]
  updateMany?: Prisma.MatchDamageUpdateManyWithWhereWithoutWeaponInput | Prisma.MatchDamageUpdateManyWithWhereWithoutWeaponInput[]
  deleteMany?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
}

export type MatchDamageUncheckedUpdateManyWithoutWeaponNestedInput = {
  create?: Prisma.XOR<Prisma.MatchDamageCreateWithoutWeaponInput, Prisma.MatchDamageUncheckedCreateWithoutWeaponInput> | Prisma.MatchDamageCreateWithoutWeaponInput[] | Prisma.MatchDamageUncheckedCreateWithoutWeaponInput[]
  connectOrCreate?: Prisma.MatchDamageCreateOrConnectWithoutWeaponInput | Prisma.MatchDamageCreateOrConnectWithoutWeaponInput[]
  upsert?: Prisma.MatchDamageUpsertWithWhereUniqueWithoutWeaponInput | Prisma.MatchDamageUpsertWithWhereUniqueWithoutWeaponInput[]
  createMany?: Prisma.MatchDamageCreateManyWeaponInputEnvelope
  set?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  disconnect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  delete?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  connect?: Prisma.MatchDamageWhereUniqueInput | Prisma.MatchDamageWhereUniqueInput[]
  update?: Prisma.MatchDamageUpdateWithWhereUniqueWithoutWeaponInput | Prisma.MatchDamageUpdateWithWhereUniqueWithoutWeaponInput[]
  updateMany?: Prisma.MatchDamageUpdateManyWithWhereWithoutWeaponInput | Prisma.MatchDamageUpdateManyWithWhereWithoutWeaponInput[]
  deleteMany?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
}

export type MatchDamageCreateWithoutMatchInput = {
  id?: string
  inflictorTeam: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  tick?: number | null
  round: Prisma.RoundCreateNestedOneWithoutDamagesInput
  weapon: Prisma.WeaponCreateNestedOneWithoutMatchDamageInput
  inflictor?: Prisma.UserCreateNestedOneWithoutDamagesAsInflictorInput
  victim?: Prisma.UserCreateNestedOneWithoutDamagesAsVictimInput
}

export type MatchDamageUncheckedCreateWithoutMatchInput = {
  id?: string
  inflictorId: number
  victimId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  roundId: string
  tick?: number | null
}

export type MatchDamageCreateOrConnectWithoutMatchInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  create: Prisma.XOR<Prisma.MatchDamageCreateWithoutMatchInput, Prisma.MatchDamageUncheckedCreateWithoutMatchInput>
}

export type MatchDamageCreateManyMatchInputEnvelope = {
  data: Prisma.MatchDamageCreateManyMatchInput | Prisma.MatchDamageCreateManyMatchInput[]
  skipDuplicates?: boolean
}

export type MatchDamageUpsertWithWhereUniqueWithoutMatchInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  update: Prisma.XOR<Prisma.MatchDamageUpdateWithoutMatchInput, Prisma.MatchDamageUncheckedUpdateWithoutMatchInput>
  create: Prisma.XOR<Prisma.MatchDamageCreateWithoutMatchInput, Prisma.MatchDamageUncheckedCreateWithoutMatchInput>
}

export type MatchDamageUpdateWithWhereUniqueWithoutMatchInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  data: Prisma.XOR<Prisma.MatchDamageUpdateWithoutMatchInput, Prisma.MatchDamageUncheckedUpdateWithoutMatchInput>
}

export type MatchDamageUpdateManyWithWhereWithoutMatchInput = {
  where: Prisma.MatchDamageScalarWhereInput
  data: Prisma.XOR<Prisma.MatchDamageUpdateManyMutationInput, Prisma.MatchDamageUncheckedUpdateManyWithoutMatchInput>
}

export type MatchDamageScalarWhereInput = {
  AND?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
  OR?: Prisma.MatchDamageScalarWhereInput[]
  NOT?: Prisma.MatchDamageScalarWhereInput | Prisma.MatchDamageScalarWhereInput[]
  id?: Prisma.UuidFilter<"MatchDamage"> | string
  inflictorId?: Prisma.IntFilter<"MatchDamage"> | number
  victimId?: Prisma.IntFilter<"MatchDamage"> | number
  inflictorTeam?: Prisma.IntFilter<"MatchDamage"> | number
  weaponId?: Prisma.IntFilter<"MatchDamage"> | number
  hitboxGroup?: Prisma.StringFilter<"MatchDamage"> | string
  damageReal?: Prisma.IntFilter<"MatchDamage"> | number
  damageNormalized?: Prisma.IntFilter<"MatchDamage"> | number
  hits?: Prisma.IntFilter<"MatchDamage"> | number
  matchId?: Prisma.UuidFilter<"MatchDamage"> | string
  roundId?: Prisma.UuidFilter<"MatchDamage"> | string
  tick?: Prisma.FloatNullableFilter<"MatchDamage"> | number | null
}

export type MatchDamageCreateWithoutInflictorInput = {
  id?: string
  inflictorTeam: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  tick?: number | null
  match: Prisma.MatchCreateNestedOneWithoutDamagesInput
  round: Prisma.RoundCreateNestedOneWithoutDamagesInput
  weapon: Prisma.WeaponCreateNestedOneWithoutMatchDamageInput
  victim?: Prisma.UserCreateNestedOneWithoutDamagesAsVictimInput
}

export type MatchDamageUncheckedCreateWithoutInflictorInput = {
  id?: string
  victimId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: string
  roundId: string
  tick?: number | null
}

export type MatchDamageCreateOrConnectWithoutInflictorInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  create: Prisma.XOR<Prisma.MatchDamageCreateWithoutInflictorInput, Prisma.MatchDamageUncheckedCreateWithoutInflictorInput>
}

export type MatchDamageCreateManyInflictorInputEnvelope = {
  data: Prisma.MatchDamageCreateManyInflictorInput | Prisma.MatchDamageCreateManyInflictorInput[]
  skipDuplicates?: boolean
}

export type MatchDamageCreateWithoutVictimInput = {
  id?: string
  inflictorTeam: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  tick?: number | null
  match: Prisma.MatchCreateNestedOneWithoutDamagesInput
  round: Prisma.RoundCreateNestedOneWithoutDamagesInput
  weapon: Prisma.WeaponCreateNestedOneWithoutMatchDamageInput
  inflictor?: Prisma.UserCreateNestedOneWithoutDamagesAsInflictorInput
}

export type MatchDamageUncheckedCreateWithoutVictimInput = {
  id?: string
  inflictorId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: string
  roundId: string
  tick?: number | null
}

export type MatchDamageCreateOrConnectWithoutVictimInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  create: Prisma.XOR<Prisma.MatchDamageCreateWithoutVictimInput, Prisma.MatchDamageUncheckedCreateWithoutVictimInput>
}

export type MatchDamageCreateManyVictimInputEnvelope = {
  data: Prisma.MatchDamageCreateManyVictimInput | Prisma.MatchDamageCreateManyVictimInput[]
  skipDuplicates?: boolean
}

export type MatchDamageUpsertWithWhereUniqueWithoutInflictorInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  update: Prisma.XOR<Prisma.MatchDamageUpdateWithoutInflictorInput, Prisma.MatchDamageUncheckedUpdateWithoutInflictorInput>
  create: Prisma.XOR<Prisma.MatchDamageCreateWithoutInflictorInput, Prisma.MatchDamageUncheckedCreateWithoutInflictorInput>
}

export type MatchDamageUpdateWithWhereUniqueWithoutInflictorInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  data: Prisma.XOR<Prisma.MatchDamageUpdateWithoutInflictorInput, Prisma.MatchDamageUncheckedUpdateWithoutInflictorInput>
}

export type MatchDamageUpdateManyWithWhereWithoutInflictorInput = {
  where: Prisma.MatchDamageScalarWhereInput
  data: Prisma.XOR<Prisma.MatchDamageUpdateManyMutationInput, Prisma.MatchDamageUncheckedUpdateManyWithoutInflictorInput>
}

export type MatchDamageUpsertWithWhereUniqueWithoutVictimInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  update: Prisma.XOR<Prisma.MatchDamageUpdateWithoutVictimInput, Prisma.MatchDamageUncheckedUpdateWithoutVictimInput>
  create: Prisma.XOR<Prisma.MatchDamageCreateWithoutVictimInput, Prisma.MatchDamageUncheckedCreateWithoutVictimInput>
}

export type MatchDamageUpdateWithWhereUniqueWithoutVictimInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  data: Prisma.XOR<Prisma.MatchDamageUpdateWithoutVictimInput, Prisma.MatchDamageUncheckedUpdateWithoutVictimInput>
}

export type MatchDamageUpdateManyWithWhereWithoutVictimInput = {
  where: Prisma.MatchDamageScalarWhereInput
  data: Prisma.XOR<Prisma.MatchDamageUpdateManyMutationInput, Prisma.MatchDamageUncheckedUpdateManyWithoutVictimInput>
}

export type MatchDamageCreateWithoutRoundInput = {
  id?: string
  inflictorTeam: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  tick?: number | null
  match: Prisma.MatchCreateNestedOneWithoutDamagesInput
  weapon: Prisma.WeaponCreateNestedOneWithoutMatchDamageInput
  inflictor?: Prisma.UserCreateNestedOneWithoutDamagesAsInflictorInput
  victim?: Prisma.UserCreateNestedOneWithoutDamagesAsVictimInput
}

export type MatchDamageUncheckedCreateWithoutRoundInput = {
  id?: string
  inflictorId: number
  victimId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: string
  tick?: number | null
}

export type MatchDamageCreateOrConnectWithoutRoundInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  create: Prisma.XOR<Prisma.MatchDamageCreateWithoutRoundInput, Prisma.MatchDamageUncheckedCreateWithoutRoundInput>
}

export type MatchDamageCreateManyRoundInputEnvelope = {
  data: Prisma.MatchDamageCreateManyRoundInput | Prisma.MatchDamageCreateManyRoundInput[]
  skipDuplicates?: boolean
}

export type MatchDamageUpsertWithWhereUniqueWithoutRoundInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  update: Prisma.XOR<Prisma.MatchDamageUpdateWithoutRoundInput, Prisma.MatchDamageUncheckedUpdateWithoutRoundInput>
  create: Prisma.XOR<Prisma.MatchDamageCreateWithoutRoundInput, Prisma.MatchDamageUncheckedCreateWithoutRoundInput>
}

export type MatchDamageUpdateWithWhereUniqueWithoutRoundInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  data: Prisma.XOR<Prisma.MatchDamageUpdateWithoutRoundInput, Prisma.MatchDamageUncheckedUpdateWithoutRoundInput>
}

export type MatchDamageUpdateManyWithWhereWithoutRoundInput = {
  where: Prisma.MatchDamageScalarWhereInput
  data: Prisma.XOR<Prisma.MatchDamageUpdateManyMutationInput, Prisma.MatchDamageUncheckedUpdateManyWithoutRoundInput>
}

export type MatchDamageCreateWithoutWeaponInput = {
  id?: string
  inflictorTeam: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  tick?: number | null
  match: Prisma.MatchCreateNestedOneWithoutDamagesInput
  round: Prisma.RoundCreateNestedOneWithoutDamagesInput
  inflictor?: Prisma.UserCreateNestedOneWithoutDamagesAsInflictorInput
  victim?: Prisma.UserCreateNestedOneWithoutDamagesAsVictimInput
}

export type MatchDamageUncheckedCreateWithoutWeaponInput = {
  id?: string
  inflictorId: number
  victimId: number
  inflictorTeam: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: string
  roundId: string
  tick?: number | null
}

export type MatchDamageCreateOrConnectWithoutWeaponInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  create: Prisma.XOR<Prisma.MatchDamageCreateWithoutWeaponInput, Prisma.MatchDamageUncheckedCreateWithoutWeaponInput>
}

export type MatchDamageCreateManyWeaponInputEnvelope = {
  data: Prisma.MatchDamageCreateManyWeaponInput | Prisma.MatchDamageCreateManyWeaponInput[]
  skipDuplicates?: boolean
}

export type MatchDamageUpsertWithWhereUniqueWithoutWeaponInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  update: Prisma.XOR<Prisma.MatchDamageUpdateWithoutWeaponInput, Prisma.MatchDamageUncheckedUpdateWithoutWeaponInput>
  create: Prisma.XOR<Prisma.MatchDamageCreateWithoutWeaponInput, Prisma.MatchDamageUncheckedCreateWithoutWeaponInput>
}

export type MatchDamageUpdateWithWhereUniqueWithoutWeaponInput = {
  where: Prisma.MatchDamageWhereUniqueInput
  data: Prisma.XOR<Prisma.MatchDamageUpdateWithoutWeaponInput, Prisma.MatchDamageUncheckedUpdateWithoutWeaponInput>
}

export type MatchDamageUpdateManyWithWhereWithoutWeaponInput = {
  where: Prisma.MatchDamageScalarWhereInput
  data: Prisma.XOR<Prisma.MatchDamageUpdateManyMutationInput, Prisma.MatchDamageUncheckedUpdateManyWithoutWeaponInput>
}

export type MatchDamageCreateManyMatchInput = {
  id?: string
  inflictorId: number
  victimId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  roundId: string
  tick?: number | null
}

export type MatchDamageUpdateWithoutMatchInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  round?: Prisma.RoundUpdateOneRequiredWithoutDamagesNestedInput
  weapon?: Prisma.WeaponUpdateOneRequiredWithoutMatchDamageNestedInput
  inflictor?: Prisma.UserUpdateOneWithoutDamagesAsInflictorNestedInput
  victim?: Prisma.UserUpdateOneWithoutDamagesAsVictimNestedInput
}

export type MatchDamageUncheckedUpdateWithoutMatchInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorId?: Prisma.IntFieldUpdateOperationsInput | number
  victimId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  weaponId?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  roundId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageUncheckedUpdateManyWithoutMatchInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorId?: Prisma.IntFieldUpdateOperationsInput | number
  victimId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  weaponId?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  roundId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageCreateManyInflictorInput = {
  id?: string
  victimId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: string
  roundId: string
  tick?: number | null
}

export type MatchDamageCreateManyVictimInput = {
  id?: string
  inflictorId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: string
  roundId: string
  tick?: number | null
}

export type MatchDamageUpdateWithoutInflictorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  match?: Prisma.MatchUpdateOneRequiredWithoutDamagesNestedInput
  round?: Prisma.RoundUpdateOneRequiredWithoutDamagesNestedInput
  weapon?: Prisma.WeaponUpdateOneRequiredWithoutMatchDamageNestedInput
  victim?: Prisma.UserUpdateOneWithoutDamagesAsVictimNestedInput
}

export type MatchDamageUncheckedUpdateWithoutInflictorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  victimId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  weaponId?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  matchId?: Prisma.StringFieldUpdateOperationsInput | string
  roundId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageUncheckedUpdateManyWithoutInflictorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  victimId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  weaponId?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  matchId?: Prisma.StringFieldUpdateOperationsInput | string
  roundId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageUpdateWithoutVictimInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  match?: Prisma.MatchUpdateOneRequiredWithoutDamagesNestedInput
  round?: Prisma.RoundUpdateOneRequiredWithoutDamagesNestedInput
  weapon?: Prisma.WeaponUpdateOneRequiredWithoutMatchDamageNestedInput
  inflictor?: Prisma.UserUpdateOneWithoutDamagesAsInflictorNestedInput
}

export type MatchDamageUncheckedUpdateWithoutVictimInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  weaponId?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  matchId?: Prisma.StringFieldUpdateOperationsInput | string
  roundId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageUncheckedUpdateManyWithoutVictimInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  weaponId?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  matchId?: Prisma.StringFieldUpdateOperationsInput | string
  roundId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageCreateManyRoundInput = {
  id?: string
  inflictorId: number
  victimId: number
  inflictorTeam: number
  weaponId: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: string
  tick?: number | null
}

export type MatchDamageUpdateWithoutRoundInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  match?: Prisma.MatchUpdateOneRequiredWithoutDamagesNestedInput
  weapon?: Prisma.WeaponUpdateOneRequiredWithoutMatchDamageNestedInput
  inflictor?: Prisma.UserUpdateOneWithoutDamagesAsInflictorNestedInput
  victim?: Prisma.UserUpdateOneWithoutDamagesAsVictimNestedInput
}

export type MatchDamageUncheckedUpdateWithoutRoundInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorId?: Prisma.IntFieldUpdateOperationsInput | number
  victimId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  weaponId?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  matchId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageUncheckedUpdateManyWithoutRoundInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorId?: Prisma.IntFieldUpdateOperationsInput | number
  victimId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  weaponId?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  matchId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageCreateManyWeaponInput = {
  id?: string
  inflictorId: number
  victimId: number
  inflictorTeam: number
  hitboxGroup: string
  damageReal: number
  damageNormalized: number
  hits: number
  matchId: string
  roundId: string
  tick?: number | null
}

export type MatchDamageUpdateWithoutWeaponInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  match?: Prisma.MatchUpdateOneRequiredWithoutDamagesNestedInput
  round?: Prisma.RoundUpdateOneRequiredWithoutDamagesNestedInput
  inflictor?: Prisma.UserUpdateOneWithoutDamagesAsInflictorNestedInput
  victim?: Prisma.UserUpdateOneWithoutDamagesAsVictimNestedInput
}

export type MatchDamageUncheckedUpdateWithoutWeaponInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorId?: Prisma.IntFieldUpdateOperationsInput | number
  victimId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  matchId?: Prisma.StringFieldUpdateOperationsInput | string
  roundId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}

export type MatchDamageUncheckedUpdateManyWithoutWeaponInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  inflictorId?: Prisma.IntFieldUpdateOperationsInput | number
  victimId?: Prisma.IntFieldUpdateOperationsInput | number
  inflictorTeam?: Prisma.IntFieldUpdateOperationsInput | number
  hitboxGroup?: Prisma.StringFieldUpdateOperationsInput | string
  damageReal?: Prisma.IntFieldUpdateOperationsInput | number
  damageNormalized?: Prisma.IntFieldUpdateOperationsInput | number
  hits?: Prisma.IntFieldUpdateOperationsInput | number
  matchId?: Prisma.StringFieldUpdateOperationsInput | string
  roundId?: Prisma.StringFieldUpdateOperationsInput | string
  tick?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
}



export type MatchDamageSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  inflictorId?: boolean
  victimId?: boolean
  inflictorTeam?: boolean
  weaponId?: boolean
  hitboxGroup?: boolean
  damageReal?: boolean
  damageNormalized?: boolean
  hits?: boolean
  matchId?: boolean
  roundId?: boolean
  tick?: boolean
  match?: boolean | Prisma.MatchDefaultArgs<ExtArgs>
  round?: boolean | Prisma.RoundDefaultArgs<ExtArgs>
  weapon?: boolean | Prisma.WeaponDefaultArgs<ExtArgs>
  inflictor?: boolean | Prisma.MatchDamage$inflictorArgs<ExtArgs>
  victim?: boolean | Prisma.MatchDamage$victimArgs<ExtArgs>
}, ExtArgs["result"]["matchDamage"]>

export type MatchDamageSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  inflictorId?: boolean
  victimId?: boolean
  inflictorTeam?: boolean
  weaponId?: boolean
  hitboxGroup?: boolean
  damageReal?: boolean
  damageNormalized?: boolean
  hits?: boolean
  matchId?: boolean
  roundId?: boolean
  tick?: boolean
  match?: boolean | Prisma.MatchDefaultArgs<ExtArgs>
  round?: boolean | Prisma.RoundDefaultArgs<ExtArgs>
  weapon?: boolean | Prisma.WeaponDefaultArgs<ExtArgs>
  inflictor?: boolean | Prisma.MatchDamage$inflictorArgs<ExtArgs>
  victim?: boolean | Prisma.MatchDamage$victimArgs<ExtArgs>
}, ExtArgs["result"]["matchDamage"]>

export type MatchDamageSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  inflictorId?: boolean
  victimId?: boolean
  inflictorTeam?: boolean
  weaponId?: boolean
  hitboxGroup?: boolean
  damageReal?: boolean
  damageNormalized?: boolean
  hits?: boolean
  matchId?: boolean
  roundId?: boolean
  tick?: boolean
  match?: boolean | Prisma.MatchDefaultArgs<ExtArgs>
  round?: boolean | Prisma.RoundDefaultArgs<ExtArgs>
  weapon?: boolean | Prisma.WeaponDefaultArgs<ExtArgs>
  inflictor?: boolean | Prisma.MatchDamage$inflictorArgs<ExtArgs>
  victim?: boolean | Prisma.MatchDamage$victimArgs<ExtArgs>
}, ExtArgs["result"]["matchDamage"]>

export type MatchDamageSelectScalar = {
  id?: boolean
  inflictorId?: boolean
  victimId?: boolean
  inflictorTeam?: boolean
  weaponId?: boolean
  hitboxGroup?: boolean
  damageReal?: boolean
  damageNormalized?: boolean
  hits?: boolean
  matchId?: boolean
  roundId?: boolean
  tick?: boolean
}

export type MatchDamageOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "inflictorId" | "victimId" | "inflictorTeam" | "weaponId" | "hitboxGroup" | "damageReal" | "damageNormalized" | "hits" | "matchId" | "roundId" | "tick", ExtArgs["result"]["matchDamage"]>
export type MatchDamageInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  match?: boolean | Prisma.MatchDefaultArgs<ExtArgs>
  round?: boolean | Prisma.RoundDefaultArgs<ExtArgs>
  weapon?: boolean | Prisma.WeaponDefaultArgs<ExtArgs>
  inflictor?: boolean | Prisma.MatchDamage$inflictorArgs<ExtArgs>
  victim?: boolean | Prisma.MatchDamage$victimArgs<ExtArgs>
}
export type MatchDamageIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  match?: boolean | Prisma.MatchDefaultArgs<ExtArgs>
  round?: boolean | Prisma.RoundDefaultArgs<ExtArgs>
  weapon?: boolean | Prisma.WeaponDefaultArgs<ExtArgs>
  inflictor?: boolean | Prisma.MatchDamage$inflictorArgs<ExtArgs>
  victim?: boolean | Prisma.MatchDamage$victimArgs<ExtArgs>
}
export type MatchDamageIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  match?: boolean | Prisma.MatchDefaultArgs<ExtArgs>
  round?: boolean | Prisma.RoundDefaultArgs<ExtArgs>
  weapon?: boolean | Prisma.WeaponDefaultArgs<ExtArgs>
  inflictor?: boolean | Prisma.MatchDamage$inflictorArgs<ExtArgs>
  victim?: boolean | Prisma.MatchDamage$victimArgs<ExtArgs>
}

export type $MatchDamagePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "MatchDamage"
  objects: {
    match: Prisma.$MatchPayload<ExtArgs>
    round: Prisma.$RoundPayload<ExtArgs>
    weapon: Prisma.$WeaponPayload<ExtArgs>
    inflictor: Prisma.$UserPayload<ExtArgs> | null
    victim: Prisma.$UserPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    inflictorId: number
    victimId: number
    inflictorTeam: number
    weaponId: number
    hitboxGroup: string
    damageReal: number
    damageNormalized: number
    hits: number
    matchId: string
    roundId: string
    tick: number | null
  }, ExtArgs["result"]["matchDamage"]>
  composites: {}
}

export type MatchDamageGetPayload<S extends boolean | null | undefined | MatchDamageDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload, S>

export type MatchDamageCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<MatchDamageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MatchDamageCountAggregateInputType | true
  }

export interface MatchDamageDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchDamage'], meta: { name: 'MatchDamage' } }
  /**
   * Find zero or one MatchDamage that matches the filter.
   * @param {MatchDamageFindUniqueArgs} args - Arguments to find a MatchDamage
   * @example
   * // Get one MatchDamage
   * const matchDamage = await prisma.matchDamage.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends MatchDamageFindUniqueArgs>(args: Prisma.SelectSubset<T, MatchDamageFindUniqueArgs<ExtArgs>>): Prisma.Prisma__MatchDamageClient<runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one MatchDamage that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {MatchDamageFindUniqueOrThrowArgs} args - Arguments to find a MatchDamage
   * @example
   * // Get one MatchDamage
   * const matchDamage = await prisma.matchDamage.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends MatchDamageFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, MatchDamageFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__MatchDamageClient<runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first MatchDamage that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchDamageFindFirstArgs} args - Arguments to find a MatchDamage
   * @example
   * // Get one MatchDamage
   * const matchDamage = await prisma.matchDamage.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends MatchDamageFindFirstArgs>(args?: Prisma.SelectSubset<T, MatchDamageFindFirstArgs<ExtArgs>>): Prisma.Prisma__MatchDamageClient<runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first MatchDamage that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchDamageFindFirstOrThrowArgs} args - Arguments to find a MatchDamage
   * @example
   * // Get one MatchDamage
   * const matchDamage = await prisma.matchDamage.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends MatchDamageFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, MatchDamageFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__MatchDamageClient<runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more MatchDamages that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchDamageFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all MatchDamages
   * const matchDamages = await prisma.matchDamage.findMany()
   * 
   * // Get first 10 MatchDamages
   * const matchDamages = await prisma.matchDamage.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const matchDamageWithIdOnly = await prisma.matchDamage.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends MatchDamageFindManyArgs>(args?: Prisma.SelectSubset<T, MatchDamageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a MatchDamage.
   * @param {MatchDamageCreateArgs} args - Arguments to create a MatchDamage.
   * @example
   * // Create one MatchDamage
   * const MatchDamage = await prisma.matchDamage.create({
   *   data: {
   *     // ... data to create a MatchDamage
   *   }
   * })
   * 
   */
  create<T extends MatchDamageCreateArgs>(args: Prisma.SelectSubset<T, MatchDamageCreateArgs<ExtArgs>>): Prisma.Prisma__MatchDamageClient<runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many MatchDamages.
   * @param {MatchDamageCreateManyArgs} args - Arguments to create many MatchDamages.
   * @example
   * // Create many MatchDamages
   * const matchDamage = await prisma.matchDamage.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends MatchDamageCreateManyArgs>(args?: Prisma.SelectSubset<T, MatchDamageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many MatchDamages and returns the data saved in the database.
   * @param {MatchDamageCreateManyAndReturnArgs} args - Arguments to create many MatchDamages.
   * @example
   * // Create many MatchDamages
   * const matchDamage = await prisma.matchDamage.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many MatchDamages and only return the `id`
   * const matchDamageWithIdOnly = await prisma.matchDamage.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends MatchDamageCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, MatchDamageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a MatchDamage.
   * @param {MatchDamageDeleteArgs} args - Arguments to delete one MatchDamage.
   * @example
   * // Delete one MatchDamage
   * const MatchDamage = await prisma.matchDamage.delete({
   *   where: {
   *     // ... filter to delete one MatchDamage
   *   }
   * })
   * 
   */
  delete<T extends MatchDamageDeleteArgs>(args: Prisma.SelectSubset<T, MatchDamageDeleteArgs<ExtArgs>>): Prisma.Prisma__MatchDamageClient<runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one MatchDamage.
   * @param {MatchDamageUpdateArgs} args - Arguments to update one MatchDamage.
   * @example
   * // Update one MatchDamage
   * const matchDamage = await prisma.matchDamage.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends MatchDamageUpdateArgs>(args: Prisma.SelectSubset<T, MatchDamageUpdateArgs<ExtArgs>>): Prisma.Prisma__MatchDamageClient<runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more MatchDamages.
   * @param {MatchDamageDeleteManyArgs} args - Arguments to filter MatchDamages to delete.
   * @example
   * // Delete a few MatchDamages
   * const { count } = await prisma.matchDamage.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends MatchDamageDeleteManyArgs>(args?: Prisma.SelectSubset<T, MatchDamageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more MatchDamages.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchDamageUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many MatchDamages
   * const matchDamage = await prisma.matchDamage.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends MatchDamageUpdateManyArgs>(args: Prisma.SelectSubset<T, MatchDamageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more MatchDamages and returns the data updated in the database.
   * @param {MatchDamageUpdateManyAndReturnArgs} args - Arguments to update many MatchDamages.
   * @example
   * // Update many MatchDamages
   * const matchDamage = await prisma.matchDamage.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more MatchDamages and only return the `id`
   * const matchDamageWithIdOnly = await prisma.matchDamage.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends MatchDamageUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, MatchDamageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one MatchDamage.
   * @param {MatchDamageUpsertArgs} args - Arguments to update or create a MatchDamage.
   * @example
   * // Update or create a MatchDamage
   * const matchDamage = await prisma.matchDamage.upsert({
   *   create: {
   *     // ... data to create a MatchDamage
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the MatchDamage we want to update
   *   }
   * })
   */
  upsert<T extends MatchDamageUpsertArgs>(args: Prisma.SelectSubset<T, MatchDamageUpsertArgs<ExtArgs>>): Prisma.Prisma__MatchDamageClient<runtime.Types.Result.GetResult<Prisma.$MatchDamagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of MatchDamages.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchDamageCountArgs} args - Arguments to filter MatchDamages to count.
   * @example
   * // Count the number of MatchDamages
   * const count = await prisma.matchDamage.count({
   *   where: {
   *     // ... the filter for the MatchDamages we want to count
   *   }
   * })
  **/
  count<T extends MatchDamageCountArgs>(
    args?: Prisma.Subset<T, MatchDamageCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], MatchDamageCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a MatchDamage.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchDamageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends MatchDamageAggregateArgs>(args: Prisma.Subset<T, MatchDamageAggregateArgs>): Prisma.PrismaPromise<GetMatchDamageAggregateType<T>>

  /**
   * Group by MatchDamage.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MatchDamageGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends MatchDamageGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: MatchDamageGroupByArgs['orderBy'] }
      : { orderBy?: MatchDamageGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, MatchDamageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchDamageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the MatchDamage model
 */
readonly fields: MatchDamageFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for MatchDamage.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__MatchDamageClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  match<T extends Prisma.MatchDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.MatchDefaultArgs<ExtArgs>>): Prisma.Prisma__MatchClient<runtime.Types.Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  round<T extends Prisma.RoundDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.RoundDefaultArgs<ExtArgs>>): Prisma.Prisma__RoundClient<runtime.Types.Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  weapon<T extends Prisma.WeaponDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.WeaponDefaultArgs<ExtArgs>>): Prisma.Prisma__WeaponClient<runtime.Types.Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  inflictor<T extends Prisma.MatchDamage$inflictorArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.MatchDamage$inflictorArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  victim<T extends Prisma.MatchDamage$victimArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.MatchDamage$victimArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the MatchDamage model
 */
export interface MatchDamageFieldRefs {
  readonly id: Prisma.FieldRef<"MatchDamage", 'String'>
  readonly inflictorId: Prisma.FieldRef<"MatchDamage", 'Int'>
  readonly victimId: Prisma.FieldRef<"MatchDamage", 'Int'>
  readonly inflictorTeam: Prisma.FieldRef<"MatchDamage", 'Int'>
  readonly weaponId: Prisma.FieldRef<"MatchDamage", 'Int'>
  readonly hitboxGroup: Prisma.FieldRef<"MatchDamage", 'String'>
  readonly damageReal: Prisma.FieldRef<"MatchDamage", 'Int'>
  readonly damageNormalized: Prisma.FieldRef<"MatchDamage", 'Int'>
  readonly hits: Prisma.FieldRef<"MatchDamage", 'Int'>
  readonly matchId: Prisma.FieldRef<"MatchDamage", 'String'>
  readonly roundId: Prisma.FieldRef<"MatchDamage", 'String'>
  readonly tick: Prisma.FieldRef<"MatchDamage", 'Float'>
}
    

// Custom InputTypes
/**
 * MatchDamage findUnique
 */
export type MatchDamageFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageInclude<ExtArgs> | null
  /**
   * Filter, which MatchDamage to fetch.
   */
  where: Prisma.MatchDamageWhereUniqueInput
}

/**
 * MatchDamage findUniqueOrThrow
 */
export type MatchDamageFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageInclude<ExtArgs> | null
  /**
   * Filter, which MatchDamage to fetch.
   */
  where: Prisma.MatchDamageWhereUniqueInput
}

/**
 * MatchDamage findFirst
 */
export type MatchDamageFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageInclude<ExtArgs> | null
  /**
   * Filter, which MatchDamage to fetch.
   */
  where?: Prisma.MatchDamageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MatchDamages to fetch.
   */
  orderBy?: Prisma.MatchDamageOrderByWithRelationInput | Prisma.MatchDamageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for MatchDamages.
   */
  cursor?: Prisma.MatchDamageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` MatchDamages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MatchDamages.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of MatchDamages.
   */
  distinct?: Prisma.MatchDamageScalarFieldEnum | Prisma.MatchDamageScalarFieldEnum[]
}

/**
 * MatchDamage findFirstOrThrow
 */
export type MatchDamageFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageInclude<ExtArgs> | null
  /**
   * Filter, which MatchDamage to fetch.
   */
  where?: Prisma.MatchDamageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MatchDamages to fetch.
   */
  orderBy?: Prisma.MatchDamageOrderByWithRelationInput | Prisma.MatchDamageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for MatchDamages.
   */
  cursor?: Prisma.MatchDamageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` MatchDamages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MatchDamages.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of MatchDamages.
   */
  distinct?: Prisma.MatchDamageScalarFieldEnum | Prisma.MatchDamageScalarFieldEnum[]
}

/**
 * MatchDamage findMany
 */
export type MatchDamageFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageInclude<ExtArgs> | null
  /**
   * Filter, which MatchDamages to fetch.
   */
  where?: Prisma.MatchDamageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of MatchDamages to fetch.
   */
  orderBy?: Prisma.MatchDamageOrderByWithRelationInput | Prisma.MatchDamageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing MatchDamages.
   */
  cursor?: Prisma.MatchDamageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` MatchDamages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` MatchDamages.
   */
  skip?: number
  distinct?: Prisma.MatchDamageScalarFieldEnum | Prisma.MatchDamageScalarFieldEnum[]
}

/**
 * MatchDamage create
 */
export type MatchDamageCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageInclude<ExtArgs> | null
  /**
   * The data needed to create a MatchDamage.
   */
  data: Prisma.XOR<Prisma.MatchDamageCreateInput, Prisma.MatchDamageUncheckedCreateInput>
}

/**
 * MatchDamage createMany
 */
export type MatchDamageCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many MatchDamages.
   */
  data: Prisma.MatchDamageCreateManyInput | Prisma.MatchDamageCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * MatchDamage createManyAndReturn
 */
export type MatchDamageCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * The data used to create many MatchDamages.
   */
  data: Prisma.MatchDamageCreateManyInput | Prisma.MatchDamageCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * MatchDamage update
 */
export type MatchDamageUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageInclude<ExtArgs> | null
  /**
   * The data needed to update a MatchDamage.
   */
  data: Prisma.XOR<Prisma.MatchDamageUpdateInput, Prisma.MatchDamageUncheckedUpdateInput>
  /**
   * Choose, which MatchDamage to update.
   */
  where: Prisma.MatchDamageWhereUniqueInput
}

/**
 * MatchDamage updateMany
 */
export type MatchDamageUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update MatchDamages.
   */
  data: Prisma.XOR<Prisma.MatchDamageUpdateManyMutationInput, Prisma.MatchDamageUncheckedUpdateManyInput>
  /**
   * Filter which MatchDamages to update
   */
  where?: Prisma.MatchDamageWhereInput
  /**
   * Limit how many MatchDamages to update.
   */
  limit?: number
}

/**
 * MatchDamage updateManyAndReturn
 */
export type MatchDamageUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * The data used to update MatchDamages.
   */
  data: Prisma.XOR<Prisma.MatchDamageUpdateManyMutationInput, Prisma.MatchDamageUncheckedUpdateManyInput>
  /**
   * Filter which MatchDamages to update
   */
  where?: Prisma.MatchDamageWhereInput
  /**
   * Limit how many MatchDamages to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * MatchDamage upsert
 */
export type MatchDamageUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageInclude<ExtArgs> | null
  /**
   * The filter to search for the MatchDamage to update in case it exists.
   */
  where: Prisma.MatchDamageWhereUniqueInput
  /**
   * In case the MatchDamage found by the `where` argument doesn't exist, create a new MatchDamage with this data.
   */
  create: Prisma.XOR<Prisma.MatchDamageCreateInput, Prisma.MatchDamageUncheckedCreateInput>
  /**
   * In case the MatchDamage was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.MatchDamageUpdateInput, Prisma.MatchDamageUncheckedUpdateInput>
}

/**
 * MatchDamage delete
 */
export type MatchDamageDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageInclude<ExtArgs> | null
  /**
   * Filter which MatchDamage to delete.
   */
  where: Prisma.MatchDamageWhereUniqueInput
}

/**
 * MatchDamage deleteMany
 */
export type MatchDamageDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which MatchDamages to delete
   */
  where?: Prisma.MatchDamageWhereInput
  /**
   * Limit how many MatchDamages to delete.
   */
  limit?: number
}

/**
 * MatchDamage.inflictor
 */
export type MatchDamage$inflictorArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  where?: Prisma.UserWhereInput
}

/**
 * MatchDamage.victim
 */
export type MatchDamage$victimArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  where?: Prisma.UserWhereInput
}

/**
 * MatchDamage without action
 */
export type MatchDamageDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the MatchDamage
   */
  select?: Prisma.MatchDamageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the MatchDamage
   */
  omit?: Prisma.MatchDamageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MatchDamageInclude<ExtArgs> | null
}
